/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.free

import scala.concurrent.duration.FiniteDuration

import cats.~>
import cats.free.Free
import cats.syntax.all.*

import cats.effect.kernel.{ Poll, Sync }

import ldbc.sql.*

import ldbc.logging.LogEvent

sealed trait ConnectionOp[A]:
  def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A]

object ConnectionOp:
  final case class Embed[A](e: Embedded[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.embed(e)
  final case class RaiseError[A](e: Throwable) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.raiseError(e)
  final case class HandleErrorWith[A](fa: ConnectionIO[A], f: Throwable => ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.handleErrorWith(fa)(f)
  case object Monotonic extends ConnectionOp[FiniteDuration]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[FiniteDuration] = v.monotonic
  case object Realtime extends ConnectionOp[FiniteDuration]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[FiniteDuration] = v.realTime
  final case class Suspend[A](hint: Sync.Type, thunk: () => A) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.suspend(hint)(thunk())
  final case class ForceR[A, B](fa: ConnectionIO[A], fb: ConnectionIO[B]) extends ConnectionOp[B]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[B] = v.forceR(fa)(fb)
  final case class Uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.uncancelable(body)
  final case class Poll1[A](poll: Any, fa: ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: Visitor[F]): F[A] = v.poll(poll, fa)
  case object Canceled extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.canceled
  final case class OnCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.onCancel(fa, fin)
  final case class PerformLogging(event: LogEvent) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.performLogging(event)

  final case class CreateStatement() extends ConnectionOp[Statement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Statement[?]] = v.createStatement()
  final case class PrepareStatement(sql: String) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] = v.prepareStatement(sql)
  final case class SetAutoCommit(autoCommit: Boolean) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.setAutoCommit(autoCommit)
  case object Commit extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.commit()
  case object Rollback extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.rollback()
  case object Close extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.close()
  final case class SetReadOnly(isReadOnly: Boolean) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.setReadOnly(isReadOnly)
  final case class PrepareStatementWithParams(
    sql:                  String,
    resultSetType:        Int,
    resultSetConcurrency: Int
  ) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] =
      v.prepareStatement(sql, resultSetType, resultSetConcurrency)
  final case class PrepareStatementWithAutoGeneratedKeys(
    sql:               String,
    autoGeneratedKeys: Int
  ) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] =
      v.prepareStatement(sql, autoGeneratedKeys)
  final case class SetSavepoint() extends ConnectionOp[Savepoint]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Savepoint] =
      v.setSavepoint()
  final case class SetSavepointWithName(name: String) extends ConnectionOp[Savepoint]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Savepoint] =
      v.setSavepoint(name)
  final case class RollbackToSavepoint(savepoint: Savepoint) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] =
      v.rollback(savepoint)
  final case class ReleaseSavepoint(savepoint: Savepoint) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] =
      v.releaseSavepoint(savepoint)

  given [F[_]]: Embeddable[ConnectionOp, Connection[F]] =
    new Embeddable[ConnectionOp, Connection[F]]:
      override def embed[A](j: Connection[F], fa: Free[ConnectionOp, A]): Embedded.Connection[F, A] =
        Embedded.Connection(j, fa)

  trait Visitor[F[_]] extends (ConnectionOp ~> F):
    final def apply[A](fa: ConnectionOp[A]): F[A] = fa.visit(this)

    def embed[A](e:            Embedded[A]):                                        F[A]
    def handleErrorWith[A](fa: ConnectionIO[A])(f:   Throwable => ConnectionIO[A]): F[A]
    def raiseError[A](err:     Throwable):                                          F[A]
    def monotonic:                                                                  F[FiniteDuration]
    def realTime:                                                                   F[FiniteDuration]
    def suspend[A](hint:       Sync.Type)(thunk:     => A):                         F[A]
    def forceR[A, B](fa:       ConnectionIO[A])(fb:  ConnectionIO[B]):              F[B]
    def uncancelable[A](body:  Poll[ConnectionIO] => ConnectionIO[A]):              F[A]
    def poll[A](poll:          Any, fa:              ConnectionIO[A]):              F[A]
    def canceled:                                                                   F[Unit]
    def onCancel[A](fa:        ConnectionIO[A], fin: ConnectionIO[Unit]):           F[A]
    def performLogging(event:  LogEvent):                                           F[Unit]

    def createStatement():                                                                F[Statement[?]]
    def prepareStatement(sql:     String):                                                F[PreparedStatement[?]]
    def setAutoCommit(autoCommit: Boolean):                                               F[Unit]
    def commit():                                                                         F[Unit]
    def rollback():                                                                       F[Unit]
    def close():                                                                          F[Unit]
    def setReadOnly(isReadOnly:   Boolean):                                               F[Unit]
    def prepareStatement(sql:     String, resultSetType: Int, resultSetConcurrency: Int): F[PreparedStatement[?]]
    def prepareStatement(
      sql:               String,
      autoGeneratedKeys: Int
    ):                                          F[PreparedStatement[?]]
    def setSavepoint():                         F[Savepoint]
    def setSavepoint(name:          String):    F[Savepoint]
    def rollback(savepoint:         Savepoint): F[Unit]
    def releaseSavepoint(savepoint: Savepoint): F[Unit]

type ConnectionIO[A] = Free[ConnectionOp, A]

object ConnectionIO:
  module =>

  def embed[F[_], J, A](j: J, fa: Free[F, A])(using ev: Embeddable[F, J]): Free[ConnectionOp, A] =
    Free.liftF(ConnectionOp.Embed(ev.embed(j, fa)))
  def pure[A](a:         A):         ConnectionIO[A] = Free.pure(a)
  def raiseError[A](err: Throwable): ConnectionIO[A] = Free.liftF(ConnectionOp.RaiseError(err))
  def handleErrorWith[A](fa: ConnectionIO[A])(f: Throwable => ConnectionIO[A]): ConnectionIO[A] =
    Free.liftF[ConnectionOp, A](ConnectionOp.HandleErrorWith(fa, f))
  val monotonic: ConnectionIO[FiniteDuration] = Free.liftF[ConnectionOp, FiniteDuration](ConnectionOp.Monotonic)
  val realtime:  ConnectionIO[FiniteDuration] = Free.liftF[ConnectionOp, FiniteDuration](ConnectionOp.Realtime)
  def suspend[A](hint: Sync.Type)(thunk: => A): ConnectionIO[A] =
    Free.liftF[ConnectionOp, A](ConnectionOp.Suspend(hint, () => thunk))
  def forceR[A, B](fa: ConnectionIO[A])(fb: ConnectionIO[B]): ConnectionIO[B] =
    Free.liftF[ConnectionOp, B](ConnectionOp.ForceR(fa, fb))
  def uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]): ConnectionIO[A] =
    Free.liftF[ConnectionOp, A](ConnectionOp.Uncancelable(body))
  val canceled: ConnectionIO[Unit] = Free.liftF[ConnectionOp, Unit](ConnectionOp.Canceled)
  def onCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]): ConnectionIO[A] =
    Free.liftF[ConnectionOp, A](ConnectionOp.OnCancel(fa, fin))
  def capturePoll[M[_]](mpoll: Poll[M]): Poll[ConnectionIO] = new Poll[ConnectionIO]:
    override def apply[A](fa: ConnectionIO[A]): ConnectionIO[A] =
      Free.liftF[ConnectionOp, A](ConnectionOp.Poll1(mpoll, fa))
  def performLogging(event: LogEvent): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.PerformLogging(event))

  def createStatement(): ConnectionIO[Statement[?]] =
    Free.liftF[ConnectionOp, Statement[?]](ConnectionOp.CreateStatement())
  def prepareStatement(sql: String): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](ConnectionOp.PrepareStatement(sql))
  def setAutoCommit(autoCommit: Boolean): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.SetAutoCommit(autoCommit))
  def commit(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Commit)
  def rollback(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Rollback)
  def close(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Close)
  def setReadOnly(isReadOnly: Boolean): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.SetReadOnly(isReadOnly))
  def prepareStatement(
    sql:                  String,
    resultSetType:        Int,
    resultSetConcurrency: Int
  ): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](
      ConnectionOp.PrepareStatementWithParams(sql, resultSetType, resultSetConcurrency)
    )
  def prepareStatement(
    sql:               String,
    autoGeneratedKeys: Int
  ): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](
      ConnectionOp.PrepareStatementWithAutoGeneratedKeys(sql, autoGeneratedKeys)
    )
  def setSavepoint(): ConnectionIO[Savepoint] =
    Free.liftF[ConnectionOp, Savepoint](ConnectionOp.SetSavepoint())
  def setSavepoint(name: String): ConnectionIO[Savepoint] =
    Free.liftF[ConnectionOp, Savepoint](ConnectionOp.SetSavepointWithName(name))
  def rollback(savepoint: Savepoint): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.RollbackToSavepoint(savepoint))
  def releaseSavepoint(savepoint: Savepoint): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.ReleaseSavepoint(savepoint))
