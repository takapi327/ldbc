/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package jdbc.connector

import java.time.*

import cats.syntax.all.*

import cats.effect.Sync

import ldbc.sql.{ PreparedStatement, ResultSet }

private[jdbc] open class PreparedStatementImpl[F[_]: Sync](statement: java.sql.PreparedStatement)
  extends PreparedStatement[F]:

  override def executeQuery(): F[ResultSet] = Sync[F].blocking(statement.executeQuery()).map(ResultSetImpl.apply)

  override def executeUpdate(): F[Int] = Sync[F].blocking(statement.executeUpdate())

  override def close(): F[Unit] =
    if statement != null
    then Sync[F].blocking(statement.close())
    else Sync[F].unit

  override def setNull(index: Int, sqlType: Int): F[Unit] =
    Sync[F].blocking(statement.setNull(index, sqlType))

  override def setBoolean(index: Int, value: Boolean): F[Unit] =
    Sync[F].blocking(statement.setBoolean(index, value))

  override def setByte(index: Int, value: Byte): F[Unit] = Sync[F].blocking(statement.setByte(index, value))

  override def setShort(index: Int, value: Short): F[Unit] =
    Sync[F].blocking(statement.setShort(index, value))

  override def setInt(index: Int, value: Int): F[Unit] = Sync[F].blocking(statement.setInt(index, value))

  override def setLong(index: Int, value: Long): F[Unit] = Sync[F].blocking(statement.setLong(index, value))

  override def setFloat(index: Int, value: Float): F[Unit] =
    Sync[F].blocking(statement.setFloat(index, value))

  override def setDouble(index: Int, value: Double): F[Unit] =
    Sync[F].blocking(statement.setDouble(index, value))

  override def setBigDecimal(index: Int, value: BigDecimal): F[Unit] =
    Sync[F].blocking(statement.setBigDecimal(index, value.bigDecimal))

  override def setString(index: Int, value: String): F[Unit] =
    Sync[F].blocking(statement.setString(index, value))

  override def setBytes(index: Int, value: Array[Byte]): F[Unit] =
    Sync[F].blocking(statement.setBytes(index, value))

  override def setDate(index: Int, value: LocalDate): F[Unit] =
    Sync[F].blocking(statement.setDate(index, java.sql.Date.valueOf(value)))

  override def setTime(index: Int, value: LocalTime): F[Unit] =
    Sync[F].blocking(statement.setTime(index, java.sql.Time.valueOf(value)))

  override def setTimestamp(index: Int, value: LocalDateTime): F[Unit] =
    Sync[F].blocking(statement.setTimestamp(index, java.sql.Timestamp.valueOf(value)))

  override def execute(): F[Boolean] = Sync[F].blocking(statement.execute())

  override def addBatch(): F[Unit] = Sync[F].blocking(statement.addBatch())

  override def getResultSet(): F[Option[ResultSet]] =
    Sync[F].blocking(Option(statement.getResultSet).map(ResultSetImpl.apply))

  override def getUpdateCount(): F[Int] = Sync[F].blocking(statement.getUpdateCount)

  override def getMoreResults(): F[Boolean] = Sync[F].blocking(statement.getMoreResults())

  override def clearBatch(): F[Unit] = Sync[F].blocking(statement.clearBatch())

  override def executeBatch(): F[Array[Int]] = Sync[F].blocking(statement.executeBatch())

  override def getGeneratedKeys(): F[ResultSet] =
    Sync[F].blocking(statement.getGeneratedKeys).map(ResultSetImpl.apply)

  override def executeUpdate(
    sql:               String,
    autoGeneratedKeys: Int
  ): F[Int] =
    Sync[F].blocking(statement.executeUpdate(sql, autoGeneratedKeys))

  override def setObject(parameterIndex: Int, value: Object): F[Unit] =
    Sync[F].blocking(statement.setObject(parameterIndex, value))

  override def execute(sql: String, autoGeneratedKeys: Int): F[Boolean] =
    Sync[F].blocking(statement.execute(sql, autoGeneratedKeys))

  override def isClosed(): F[Boolean] = Sync[F].blocking(statement.isClosed)

  override def getLargeUpdateCount(): F[Long] = Sync[F].blocking(statement.getLargeUpdateCount)

  override def executeLargeUpdate(): F[Long] =
    Sync[F].blocking(statement.executeLargeUpdate())

  override def executeLargeBatch(): F[Array[Long]] =
    Sync[F].blocking(statement.executeLargeBatch())
