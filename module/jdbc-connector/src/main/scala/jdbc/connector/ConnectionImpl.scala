/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package jdbc.connector

import cats.syntax.all.*

import cats.effect.Sync

import ldbc.sql.*
import ldbc.sql.logging.LogHandler

private[jdbc] case class ConnectionImpl[F[_]: Sync](connection: java.sql.Connection, logHandler: LogHandler[F])
  extends Connection[F]:

  override def createStatement(): F[Statement[F]] =
    Sync[F].blocking(connection.createStatement()).map(StatementImpl.apply)

  override def prepareStatement(sql: String): F[PreparedStatement[F]] =
    Sync[F].blocking(connection.prepareStatement(sql)).map(PreparedStatementImpl(_))

  override def prepareCall(sql: String): F[CallableStatement[F]] =
    Sync[F].blocking(connection.prepareCall(sql)).map(CallableStatementImpl.apply)

  override def nativeSQL(sql: String): F[String] = Sync[F].blocking(connection.nativeSQL(sql))

  override def setAutoCommit(autoCommit: Boolean): F[Unit] = Sync[F].blocking(connection.setAutoCommit(autoCommit))

  override def getAutoCommit(): F[Boolean] = Sync[F].blocking(connection.getAutoCommit)

  override def commit(): F[Unit] = Sync[F].blocking(connection.commit())

  override def rollback(): F[Unit] = Sync[F].blocking(connection.rollback())

  override def close(): F[Unit] = Sync[F].blocking(connection.close())

  override def isClosed(): F[Boolean] = Sync[F].blocking(connection.isClosed)

  override def getMetaData(): F[DatabaseMetaData[F]] =
    Sync[F].blocking(connection.getMetaData).map(conn => DatabaseMetaDataImpl[F](conn, logHandler))

  override def setReadOnly(readOnly: Boolean): F[Unit] = Sync[F].blocking(connection.setReadOnly(readOnly))

  override def isReadOnly: F[Boolean] = Sync[F].blocking(connection.isReadOnly)

  override def setCatalog(catalog: String): F[Unit] = Sync[F].blocking(connection.setCatalog(catalog))

  override def getCatalog(): F[String] = Sync[F].blocking(connection.getCatalog)

  override def setTransactionIsolation(level: Int): F[Unit] =
    Sync[F].blocking(connection.setTransactionIsolation(level))

  override def getTransactionIsolation(): F[Int] = Sync[F].blocking(connection.getTransactionIsolation)

  override def createStatement(
    resultSetType:        Int,
    resultSetConcurrency: Int
  ): F[Statement[F]] =
    Sync[F].blocking(connection.createStatement(resultSetType, resultSetConcurrency)).map(StatementImpl.apply)

  override def prepareStatement(
    sql:                  String,
    resultSetType:        Int,
    resultSetConcurrency: Int
  ): F[PreparedStatement[F]] =
    Sync[F]
      .blocking(connection.prepareStatement(sql, resultSetType, resultSetConcurrency))
      .map(PreparedStatementImpl(_))

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[CallableStatement[F]] =
    Sync[F].blocking(connection.prepareCall(sql, resultSetType, resultSetConcurrency)).map(CallableStatementImpl.apply)

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): F[PreparedStatement[F]] =
    Sync[F].blocking(connection.prepareStatement(sql, autoGeneratedKeys)).map(PreparedStatementImpl(_))

  override def isValid(timeout: Int): F[Boolean] = Sync[F].blocking(connection.isValid(timeout))

  override def setSchema(schema: String): F[Unit] = Sync[F].blocking(connection.setSchema(schema))

  override def getSchema(): F[String] = Sync[F].blocking(connection.getSchema)

  override def setSavepoint(): F[Savepoint] = Sync[F].blocking(connection.setSavepoint()).map(MysqlSavepoint.apply)

  override def setSavepoint(name: String): F[Savepoint] =
    Sync[F].blocking(connection.setSavepoint(name)).map(MysqlSavepoint.apply)

  override def rollback(savepoint: Savepoint): F[Unit] =
    Sync[F].blocking(connection.rollback(MysqlSavepoint.toJdbc(savepoint)))

  override def releaseSavepoint(savepoint: Savepoint): F[Unit] =
    Sync[F].blocking(connection.releaseSavepoint(MysqlSavepoint.toJdbc(savepoint)))
