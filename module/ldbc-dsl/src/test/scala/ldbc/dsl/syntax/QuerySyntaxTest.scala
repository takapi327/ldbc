/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl.syntax

import org.scalatest.flatspec.AnyFlatSpec

class QuerySyntaxTest extends AnyFlatSpec:

  it should "It can be converted to the model specified by the toList method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query = user.selectAll.toList[User]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the toList method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.toList[FailedUser]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the toList method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query: Kleisli[IO, Connection[IO], List[(Long, String, Int)]] = user.selectAll.toList
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the headOption method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query = user.selectAll.where(_.id === 1).headOption[User]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the headOption method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).headOption[FailedUser]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the headOption method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query: Kleisli[IO, Connection[IO], Option[(Long, String, Int)]] = user.selectAll.where(_.id === 1).headOption
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the unsafe method." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query: Kleisli[IO, Connection[IO], User] = user.selectAll.where(_.id === 1).unsafe[User]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the unsafe method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).unsafe[FailedUser]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the unsafe method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |val query: Kleisli[IO, Connection[IO], (Long, String, Int)] = user.selectAll.where(_.id === 1).unsafe
        |""".stripMargin
    )
  }

  it should "The type of the Tuple generated by the Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT),
        |    column("categoryId", BIGINT)
        |  )
        |
        |case class Category(id: Long, name: String)
        |object Category:
        |  val table = Table[Category]("category")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |val category = TableQuery[IO, Category](Category.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query: Kleisli[IO, Connection[IO], List[(String, String)]] = (user join category)((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .toList
        |""".stripMargin
    )
  }

  it should "The type generated by the join matches the type of the specified model." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT),
        |    column("categoryId", BIGINT)
        |  )
        |
        |case class Category(id: Long, name: String)
        |object Category:
        |  val table = Table[Category]("category")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |val category = TableQuery[IO, Category](Category.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query = (user join category)((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .toList[UserCategory]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Left Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class Country(code: String, name: String)
        |object Country:
        |  val table = Table[Country]("country")(
        |    column("code", CHAR(3), PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |case class City(id: Long, name: String, countryCode: String)
        |object City:
        |  val table = Table[City]("city")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("country_code", CHAR(3))
        |  )
        |    .keySets(table => Seq(
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("city_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |)
        |object CountryLanguage:
        |  val table: Table[CountryLanguage] = Table[CountryLanguage]("country_language")(
        |    column("country_code", CHAR(3)),
        |    column("language", CHAR(30))
        |  )
        |    .keySets(table => Seq(
        |      PRIMARY_KEY(table.countryCode, table.language),
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("countryLanguage_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |val countryQuery = TableQuery[IO, Country](Country.table)
        |val cityQuery = TableQuery[IO, City](City.table)
        |val countryLanguageQuery = TableQuery[IO, CountryLanguage](CountryLanguage.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |
        |val query: Kleisli[IO, Connection[IO], List[(String, String, Option[String])]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .toList
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Right Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class Country(code: String, name: String)
        |object Country:
        |  val table = Table[Country]("country")(
        |    column("code", CHAR(3), PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |case class City(id: Long, name: String, countryCode: String)
        |object City:
        |  val table = Table[City]("city")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("country_code", CHAR(3))
        |  )
        |    .keySets(table => Seq(
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("city_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |)
        |object CountryLanguage:
        |  val table: Table[CountryLanguage] = Table[CountryLanguage]("country_language")(
        |    column("country_code", CHAR(3)),
        |    column("language", CHAR(30))
        |  )
        |    .keySets(table => Seq(
        |      PRIMARY_KEY(table.countryCode, table.language),
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("countryLanguage_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |val countryQuery = TableQuery[IO, Country](Country.table)
        |val cityQuery = TableQuery[IO, City](City.table)
        |val countryLanguageQuery = TableQuery[IO, CountryLanguage](CountryLanguage.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |
        |val query: Kleisli[IO, Connection[IO], List[(Option[String], Option[String], String)]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .rightJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .toList
        |""".stripMargin
    )
  }

  it should "When a column of type Option is made into type Option with Right Join, Option is not nested." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.*
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class Country(code: String, name: String)
        |object Country:
        |  val table = Table[Country]("country")(
        |    column("code", CHAR(3), PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |case class City(id: Long, name: String, countryCode: String)
        |object City:
        |  val table = Table[City]("city")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("country_code", CHAR(3))
        |  )
        |    .keySets(table => Seq(
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("city_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    Option[String]
        |)
        |object CountryLanguage:
        |  val table: Table[CountryLanguage] = Table[CountryLanguage]("country_language")(
        |    column("country_code", CHAR(3)),
        |    column("language", CHAR(30))
        |  )
        |    .keySets(table => Seq(
        |      PRIMARY_KEY(table.countryCode, table.language),
        |      INDEX_KEY(table.countryCode),
        |      CONSTRAINT("countryLanguage_ibfk_1", FOREIGN_KEY(table.countryCode, REFERENCE(Country.table, Country.table.code)))
        |    ))
        |
        |val countryQuery = TableQuery[IO, Country](Country.table)
        |val cityQuery = TableQuery[IO, City](City.table)
        |val countryLanguageQuery = TableQuery[IO, CountryLanguage](CountryLanguage.table)
        |
        |given LogHandler[IO] = LogHandler.noop[IO]
        |
        |val query: Kleisli[IO, Connection[IO], List[(String, String, Option[String])]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .toList
        |""".stripMargin
    )
  }
