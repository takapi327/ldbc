/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl

import cats.*
import cats.data.Kleisli
import cats.syntax.all.*

import ldbc.sql.ResultSet

/**
 * Trait for generating the specified data type from a ResultSet.
 *
 * @tparam F
 *   The effect type
 * @tparam T
 *   Type you want to build with data obtained from ResultSet
 */
trait ResultSetConsumer[F[_], T]:

  /**
   * Method for generating the specified data type from a ResultSet.
   *
   * @param resultSet
   *   A table of data representing a database result set, which is usually generated by executing a statement that
   *   queries the database.
   * @return
   *   Type you want to build with data obtained from ResultSet
   */
  def consume(resultSet: ResultSet[F]): F[T]

object ResultSetConsumer:

  given [F[_], T](using
    consumer: ResultSetConsumer[F, Option[T]],
    error:    MonadError[F, Throwable]
  ): ResultSetConsumer[F, T] with
    override def consume(resultSet: ResultSet[F]): F[T] =
      consumer.consume(resultSet).flatMap {
        case Some(value) => error.pure(value)
        case None        => error.raiseError(new NoSuchElementException(""))
      }

  given [F[_]: Monad, T](using resultSetKleisli: Kleisli[F, ResultSet[F], T]): ResultSetConsumer[F, Option[T]] with
    override def consume(resultSet: ResultSet[F]): F[Option[T]] =
      for
        hasNext <- resultSet.next()
        result  <- if hasNext then resultSetKleisli.run(resultSet).map(_.some) else Monad[F].pure(None)
      yield result

  given [F[_]: Monad, T, G[_]: Applicative: MonoidK](using
    resultSetKleisli: Kleisli[F, ResultSet[F], T]
  ): ResultSetConsumer[F, G[T]] with
    override def consume(resultSet: ResultSet[F]): F[G[T]] =
      def loop(acc: G[T]): F[G[T]] =
        resultSet.next().flatMap {
          case false => Monad[F].pure(acc)
          case true  => resultSetKleisli.run(resultSet).flatMap(v => loop(acc <+> Applicative[G].pure(v)))
        }
      loop(MonoidK[G].empty)
