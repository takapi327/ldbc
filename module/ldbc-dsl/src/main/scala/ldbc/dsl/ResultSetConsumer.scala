/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl

import cats.*
import cats.syntax.all.*

import ldbc.sql.ResultSet

import ldbc.dsl.codec.Decoder
import ldbc.dsl.exception.DecodeFailureException
import ldbc.dsl.util.FactoryCompat

/**
 * Trait for generating the specified data type from a ResultSet.
 *
 * @tparam F
 *   The effect type
 * @tparam T
 *   Type you want to build with data obtained from ResultSet
 */
trait ResultSetConsumer[F[_], T]:

  /**
   * Method for generating the specified data type from a ResultSet.
   *
   * @param resultSet
   *   A table of data representing a database result set, which is usually generated by executing a statement that
   *   queries the database.
   * @param statement
   *   Statement that configured the ResultSet
   * @return
   *   Type you want to build with data obtained from ResultSet
   */
  def consume(resultSet: ResultSet, statement: String): F[T]

object ResultSetConsumer:

  private val FIRST_OFFSET = 1

  given [F[_], T](using
    consumer: ResultSetConsumer[F, Option[T]],
    ev:       MonadThrow[F]
  ): ResultSetConsumer[F, T] with
    override def consume(resultSet: ResultSet, statement: String): F[T] =
      consumer.consume(resultSet, statement).flatMap {
        case Some(value) => ev.pure(value)
        case None        => ev.raiseError(new NoSuchElementException(""))
      }

  given [F[_], T](using decoder: Decoder[T], ev: ApplicativeThrow[F]): ResultSetConsumer[F, Option[T]] with
    override def consume(resultSet: ResultSet, statement: String): F[Option[T]] =
      if resultSet.next() then
        decoder.decode(resultSet, FIRST_OFFSET) match
          case Right(value) => ev.pure(Some(value))
          case Left(error) =>
            ev.raiseError(new DecodeFailureException(error.message, decoder.offset, statement, error.cause))
      else ev.pure(None)

  given [F[_]: Applicative, T, G[_]](using
    decoder:       Decoder[T],
    factoryCompat: FactoryCompat[T, G[T]]
  ): ResultSetConsumer[F, G[T]] with
    override def consume(resultSet: ResultSet, statement: String): F[G[T]] =
      val builder = factoryCompat.newBuilder
      while resultSet.next() do
        decoder.decode(resultSet, FIRST_OFFSET) match
          case Right(value) => builder += value
          case Left(error)  => throw new DecodeFailureException(error.message, decoder.offset, statement, error.cause)
      Applicative[F].pure(builder.result())
