/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.pool

import cats.effect.*

import ldbc.sql.*

import ldbc.connector.Connection

/**
 * A proxy for pooled connections that intercepts close() calls to return
 * connections to the pool instead of actually closing them.
 *
 * @param pooled the pooled connection being wrapped
 * @param releaseCallback callback to invoke when the connection is released
 * @tparam F the effect type
 */
private[pool] class ConnectionProxy[F[_]: Temporal](
  val pooled:      PooledConnection[F],
  releaseCallback: Connection[F] => F[Unit]
) extends Connection[F]:

  private def delegate: Connection[F] = pooled.connection

  // Override close to return to pool instead of closing
  override def close(): F[Unit] = releaseCallback(this)

  // Delegate all other methods
  override def createStatement(): F[Statement[F]] = delegate.createStatement()

  override def prepareStatement(sql: String): F[PreparedStatement[F]] = delegate.prepareStatement(sql)

  override def prepareCall(sql: String): F[CallableStatement[F]] = delegate.prepareCall(sql)

  override def nativeSQL(sql: String): F[String] = delegate.nativeSQL(sql)

  override def getAutoCommit(): F[Boolean] = delegate.getAutoCommit()

  override def setAutoCommit(autoCommit: Boolean): F[Unit] = delegate.setAutoCommit(autoCommit)

  override def commit(): F[Unit] = delegate.commit()

  override def rollback(): F[Unit] = delegate.rollback()

  override def getTransactionIsolation(): F[Int] = delegate.getTransactionIsolation()

  override def setTransactionIsolation(level: Int): F[Unit] = delegate.setTransactionIsolation(level)

  override def isReadOnly: F[Boolean] = delegate.isReadOnly

  override def setReadOnly(readOnly: Boolean): F[Unit] = delegate.setReadOnly(readOnly)

  override def getCatalog(): F[String] = delegate.getCatalog()

  override def setCatalog(catalog: String): F[Unit] = delegate.setCatalog(catalog)

  override def isClosed(): F[Boolean] = delegate.isClosed()

  override def isValid(timeout: Int): F[Boolean] = delegate.isValid(timeout)

  override def getMetaData(): F[DatabaseMetaData[F]] = delegate.getMetaData()

  override def setSavepoint(): F[Savepoint] = delegate.setSavepoint()

  override def setSavepoint(name: String): F[Savepoint] = delegate.setSavepoint(name)

  override def releaseSavepoint(savepoint: Savepoint): F[Unit] = delegate.releaseSavepoint(savepoint)

  override def rollback(savepoint: Savepoint): F[Unit] = delegate.rollback(savepoint)

  // Additional methods from Connection interface
  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): F[Statement[F]] =
    delegate.createStatement(resultSetType, resultSetConcurrency)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[PreparedStatement[F]] =
    delegate.prepareStatement(sql, resultSetType, resultSetConcurrency)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[CallableStatement[F]] =
    delegate.prepareCall(sql, resultSetType, resultSetConcurrency)

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): F[PreparedStatement[F]] =
    delegate.prepareStatement(sql, autoGeneratedKeys)

  override def setSchema(schema: String): F[Unit] = delegate.setSchema(schema)

  override def getSchema(): F[String] = delegate.getSchema()
