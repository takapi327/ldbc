/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.net.protocol

import scala.collection.immutable.{ ListMap, SortedMap }

import cats.*
import cats.syntax.all.*

import cats.effect.*

import org.typelevel.otel4s.trace.{ Span, StatusCode, Tracer }
import org.typelevel.otel4s.Attribute

import ldbc.sql.{ ResultSet, Statement }

import ldbc.connector.{ ResultSetImpl, StreamingResultSet }
import ldbc.connector.data.*
import ldbc.connector.exception.SQLException
import ldbc.connector.net.packet.request.*
import ldbc.connector.net.packet.response.*
import ldbc.connector.net.Protocol
import ldbc.connector.telemetry.*

/**
 * PreparedStatement for query construction at the server side.
 *
 * @param protocol
 *   Protocol is a protocol to communicate with MySQL server.
 * @param statementId
 *   the statement id
 * @param sql
 *   the SQL statement
 * @param params
 *   the parameters
 * @tparam F
 *   The effect type
 */
case class ServerPreparedStatement[F[_]: Exchange: Tracer: Sync](
  protocol:             Protocol[F],
  serverVariables:      Map[String, String],
  statementId:          Long,
  sql:                  String,
  params:               Ref[F, SortedMap[Int, Parameter]],
  batchedArgs:          Ref[F, Vector[String]],
  connectionClosed:     Ref[F, Boolean],
  statementClosed:      Ref[F, Boolean],
  resultSetClosed:      Ref[F, Boolean],
  currentResultSet:     Ref[F, Option[ResultSet[F]]],
  updateCount:          Ref[F, Long],
  moreResults:          Ref[F, Boolean],
  autoGeneratedKeys:    Ref[F, Int],
  lastInsertId:         Ref[F, Long],
  fetchSize:            Ref[F, Int],
  useCursorFetch:       Boolean,
  useServerPrepStmts:   Boolean,
  resultSetType:        Int             = ResultSet.TYPE_FORWARD_ONLY,
  resultSetConcurrency: Int             = ResultSet.CONCUR_READ_ONLY,
  telemetryConfig:      TelemetryConfig = TelemetryConfig.default
)(using F: MonadThrow[F])
  extends SharedPreparedStatement[F]:

  private val baseAttributes = buildBaseAttributes(protocol)

  private def buildResultSet(
    columnDefinitions: Vector[ColumnDefinitionPacket],
    records:           Vector[ResultSetRowPacket]
  ): ResultSet[F] =
    if useCursorFetch then
      StreamingResultSet(
        protocol,
        statementId,
        columnDefinitions,
        records,
        serverVariables,
        protocol.initialPacket.serverVersion,
        resultSetClosed,
        fetchSize,
        useCursorFetch,
        useServerPrepStmts,
        resultSetType,
        resultSetConcurrency,
        Some(sql)
      )
    else
      ResultSetImpl(
        protocol,
        columnDefinitions,
        records,
        serverVariables,
        protocol.initialPacket.serverVersion,
        resultSetClosed,
        fetchSize,
        useCursorFetch,
        useServerPrepStmts,
        resultSetType,
        resultSetConcurrency,
        Some(sql)
      )

  override def executeQuery(): F[ResultSet[F]] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> exchange[F, ResultSet[F]](
      telemetryConfig.resolveSpanName(
        sql,
        TelemetrySpanName.STMT_EXECUTE_PREPARED,
        protocol.hostInfo.database,
        Some(protocol.hostInfo.host),
        Some(protocol.hostInfo.port)
      )
    ) { (span: Span[F]) =>
      val processedSql    = telemetryConfig.processQueryText(sql)
      val queryAttributes = baseAttributes ++ List(
        TelemetryAttribute.dbQueryText(processedSql)
      ) ++ telemetryConfig.getOperationName(sql).map(TelemetryAttribute.dbOperationName).toList

      for
        parameter   <- params.get
        _           <- span.addAttributes(queryAttributes*)
        columnCount <-
          protocol.resetSequenceId *>
            protocol.send(
              ComStmtExecutePacket(statementId, parameter, resultSetType, resultSetConcurrency, useCursorFetch)
            ) *>
            protocol.receive(ColumnsNumberPacket.decoder(protocol.initialPacket.capabilityFlags)).flatMap {
              case _: OKPacket      => F.pure(ColumnsNumberPacket(0))
              case error: ERRPacket =>
                val exception = error.toException(Some(sql), None, parameter)
                span.addAttributes(error.attributes*) *>
                  span.recordException(exception, error.attributes*) *>
                  span.setStatus(StatusCode.Error, exception.getMessage) *>
                  F.raiseError(exception)
              case result: ColumnsNumberPacket => F.pure(result)
            }
        columnDefinitions <-
          protocol.repeatProcess(
            columnCount.size,
            ColumnDefinitionPacket.decoder(protocol.initialPacket.capabilityFlags)
          )
        resultSetRow <-
          protocol.readUntilEOF[BinaryProtocolResultSetRowPacket](
            BinaryProtocolResultSetRowPacket.decoder(protocol.initialPacket.capabilityFlags, columnDefinitions)
          )
        _ <- columnDefinitions.headOption match {
               case None         => F.unit
               case Some(column) => span.addAttribute(TelemetryAttribute.dbCollectionName(column.table))
             }
        _ <- params.set(SortedMap.empty)
        resultSet = buildResultSet(columnDefinitions, resultSetRow)
        _ <- currentResultSet.set(Some(resultSet))
      yield resultSet
    }

  override def executeLargeUpdate(): F[Long] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> exchange[F, Long](
      telemetryConfig.resolveSpanName(
        sql,
        TelemetrySpanName.STMT_EXECUTE_PREPARED,
        protocol.hostInfo.database,
        Some(protocol.hostInfo.host),
        Some(protocol.hostInfo.port)
      )
    ) { (span: Span[F]) =>
      params.get.flatMap { params =>
        val processedSql    = telemetryConfig.processQueryText(sql)
        val queryAttributes = baseAttributes ++ List(
          TelemetryAttribute.dbQueryText(processedSql)
        ) ++ telemetryConfig.getOperationName(sql).map(TelemetryAttribute.dbOperationName).toList

        span.addAttributes(queryAttributes*) *>
          protocol.resetSequenceId *>
          protocol.send(
            ComStmtExecutePacket(statementId, params, resultSetType, resultSetConcurrency, useCursorFetch)
          ) *>
          protocol.receive(GenericResponsePackets.decoder(protocol.initialPacket.capabilityFlags)).flatMap {
            case result: OKPacket => lastInsertId.set(result.lastInsertId) *> F.pure(result.affectedRows)
            case error: ERRPacket =>
              val exception = error.toException(Some(sql), None, params)
              span.addAttributes(error.attributes*) *>
                span.recordException(exception, error.attributes*) *>
                span.setStatus(StatusCode.Error, exception.getMessage) *>
                F.raiseError(exception)
            case eof: EOFPacket =>
              val exception = new SQLException("Unexpected EOF packet")
              span.addAttribute(TelemetryAttribute.errorType(exception)) *>
                span.recordException(exception, eof.attribute) *>
                span.setStatus(StatusCode.Error, exception.getMessage) *>
                F.raiseError(exception)
          }
      } <* params.set(SortedMap.empty)
    }

  override def execute(): F[Boolean] =
    if sql.toUpperCase.startsWith("SELECT") then
      executeQuery().flatMap {
        case resultSet: ResultSetImpl[F] => resultSet.hasRows()
        case _                           => F.pure(false)
      }
    else executeUpdate().map(_ => false)

  override def addBatch(): F[Unit] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> params.get.flatMap { params =>
      batchedArgs.update(_ :+ buildBatchQuery(sql, params))
    } *> params.set(SortedMap.empty)

  override def clearBatch(): F[Unit] = batchedArgs.set(Vector.empty)

  override def executeLargeBatch(): F[Array[Long]] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> (
      sql.trim.toLowerCase match
        case q if q.startsWith("insert") =>
          exchange[F, Array[Long]](TelemetrySpanName.STMT_EXECUTE_BATCH_PREPARED) { (span: Span[F]) =>
            protocol.resetSequenceId *>
              batchedArgs.get.flatMap { args =>
                val batchAttributes = baseAttributes ++
                  List(TelemetryAttribute.dbOperationName(TelemetryAttribute.SqlOperation.BATCH)) ++
                  TelemetryAttribute.dbOperationBatchSize(args.length).toList

                if args.isEmpty then F.pure(Array.empty)
                else
                  span.addAttributes(batchAttributes*) *>
                    protocol.resetSequenceId *>
                    protocol.send(
                      ComQueryPacket(
                        sql.split("VALUES").head + " VALUES" + args.mkString(","),
                        protocol.initialPacket.capabilityFlags,
                        ListMap.empty
                      )
                    ) *>
                    protocol
                      .receive(GenericResponsePackets.decoder(protocol.initialPacket.capabilityFlags))
                      .flatMap {
                        case _: OKPacket      => F.pure(Array.fill(args.length)(Statement.SUCCESS_NO_INFO.toLong))
                        case error: ERRPacket =>
                          val exception = error.toException(Some(sql), None)
                          span.addAttributes(error.attributes*) *>
                            span.recordException(exception, error.attributes*) *>
                            span.setStatus(StatusCode.Error, exception.getMessage) *>
                            F.raiseError(exception)
                        case eof: EOFPacket =>
                          val exception = new SQLException("Unexpected EOF packet")
                          span.addAttribute(TelemetryAttribute.errorType(exception)) *>
                            span.recordException(exception, eof.attribute) *>
                            span.setStatus(StatusCode.Error, exception.getMessage) *>
                            F.raiseError(exception)
                      }
              }
          } <* params.set(SortedMap.empty) <* batchedArgs.set(Vector.empty)
        case q if q.startsWith("update") || q.startsWith("delete") =>
          protocol.resetSequenceId *>
            protocol.comSetOption(EnumMySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_ON) *>
            exchange[F, Array[Long]](TelemetrySpanName.STMT_EXECUTE_BATCH_PREPARED) { (span: Span[F]) =>
              protocol.resetSequenceId *>
                batchedArgs.get.flatMap { args =>
                  val batchAttributes = baseAttributes ++
                    List(TelemetryAttribute.dbOperationName(TelemetryAttribute.SqlOperation.BATCH)) ++
                    TelemetryAttribute.dbOperationBatchSize(args.length).toList

                  if args.isEmpty then F.pure(Array.empty)
                  else
                    span.addAttributes(batchAttributes*) *>
                      protocol.resetSequenceId *>
                      protocol.send(
                        ComQueryPacket(
                          args.mkString(";"),
                          protocol.initialPacket.capabilityFlags,
                          ListMap.empty
                        )
                      ) *>
                      args
                        .foldLeft(F.pure(Vector.empty[Long])) { ($acc, _) =>
                          for
                            acc    <- $acc
                            result <-
                              protocol
                                .receive(GenericResponsePackets.decoder(protocol.initialPacket.capabilityFlags))
                                .flatMap {
                                  case result: OKPacket =>
                                    lastInsertId.set(result.lastInsertId) *> F.pure(acc :+ result.affectedRows)
                                  case error: ERRPacket =>
                                    val exception = error.toException("Failed to execute batch", acc)
                                    span.addAttributes(error.attributes*) *>
                                      span.recordException(exception, error.attributes*) *>
                                      span.setStatus(StatusCode.Error, exception.getMessage) *>
                                      F.raiseError(exception)
                                  case eof: EOFPacket =>
                                    val exception = new SQLException("Unexpected EOF packet")
                                    span.addAttribute(TelemetryAttribute.errorType(exception)) *>
                                      span.recordException(exception, eof.attribute) *>
                                      span.setStatus(StatusCode.Error, exception.getMessage) *>
                                      F.raiseError(exception)
                                }
                          yield result
                        }
                        .map(_.toArray)
                }
            } <*
            protocol.resetSequenceId <*
            protocol.comSetOption(EnumMySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_OFF) <*
            params.set(SortedMap.empty) <*
            batchedArgs.set(Vector.empty)
        case _ =>
          F.raiseError(
            new IllegalArgumentException("The batch query must be an INSERT, UPDATE, or DELETE statement.")
          )
    )

  override def getGeneratedKeys(): F[ResultSet[F]] =
    autoGeneratedKeys.get.flatMap {
      case Statement.RETURN_GENERATED_KEYS =>
        for
          lastInsertId <- lastInsertId.get
          record    = ResultSetRowPacket(Array(Some(lastInsertId.toString)))
          resultSet = ResultSetImpl(
                        protocol,
                        Vector(new ColumnDefinitionPacket:
                          override def table:      String                     = ""
                          override def name:       String                     = "GENERATED_KEYS"
                          override def columnType: ColumnDataType             = ColumnDataType.MYSQL_TYPE_LONGLONG
                          override def flags:      Seq[ColumnDefinitionFlags] = Seq.empty),
                        Vector(record),
                        serverVariables,
                        protocol.initialPacket.serverVersion,
                        resultSetClosed,
                        fetchSize,
                        useCursorFetch,
                        useServerPrepStmts
                      )
          _ <- currentResultSet.set(Some(resultSet))
        yield resultSet
      case Statement.NO_GENERATED_KEYS =>
        F.raiseError(
          new SQLException(
            "Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement()."
          )
        )
    }

  override def close(): F[Unit] =
    exchange[F, Unit](TelemetrySpanName.STMT_DEALLOCATE_PREPARED) { (span: Span[F]) =>
      val closeAttributes = baseAttributes ++ List(
        TelemetryAttribute.dbOperationName("CLOSE")
      )

      span.addAttributes(closeAttributes*) *> protocol.resetSequenceId *> protocol.send(
        ComStmtClosePacket(statementId)
      ) *> statementClosed.set(
        true
      ) *> resultSetClosed.set(true)
    }
