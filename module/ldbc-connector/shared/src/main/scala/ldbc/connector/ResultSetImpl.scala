/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector

import java.time.*
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAccessor

import cats.syntax.all.*
import cats.MonadThrow

import cats.effect.Ref

import ldbc.sql.ResultSet

import ldbc.connector.net.packet.response.*
import ldbc.connector.net.Protocol
import ldbc.connector.util.Version

/**
 * A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
 */
private[ldbc] case class ResultSetImpl[F[_]](
  protocol:             Protocol[F],
  columns:              Vector[ColumnDefinitionPacket],
  records:              Vector[ResultSetRowPacket],
  serverVariables:      Map[String, String],
  version:              Version,
  isClosed:             Ref[F, Boolean],
  fetchSize:            Ref[F, Int],
  useCursorFetch:       Boolean,
  useServerPrepStmts:   Boolean,
  resultSetType:        Int            = ResultSet.TYPE_FORWARD_ONLY,
  resultSetConcurrency: Int            = ResultSet.CONCUR_READ_ONLY,
  statement:            Option[String] = None
)(using ev: MonadThrow[F])
  extends SharedResultSet[F]:

  override def next(): F[Boolean] =
    checkClosed().map { _ =>
      if currentCursor < records.length then
        // Use apply instead of lift for index access from a performance standpoint.
        currentRow    = Some(records(currentCursor))
        currentCursor = currentCursor + 1
        true
      else
        currentCursor = currentCursor + 1
        currentRow    = None
        false
    }

private[ldbc] object ResultSetImpl:

  private[ldbc] final val CLOSED_MESSAGE = "Operation not allowed after ResultSet closed"

  private[ldbc] def temporalDecode[A <: TemporalAccessor](
    formatter: DateTimeFormatter,
    parse:     (String, DateTimeFormatter) => A
  ): String => A = str => parse(str, formatter)

  def apply[F[_]: MonadThrow](
    protocol:           Protocol[F],
    columns:            Vector[ColumnDefinitionPacket],
    records:            Vector[ResultSetRowPacket],
    serverVariables:    Map[String, String],
    version:            Version,
    isClosed:           Ref[F, Boolean],
    fetchSize:          Ref[F, Int],
    useCursorFetch:     Boolean,
    useServerPrepStmts: Boolean
  ): ResultSetImpl[F] =
    ResultSetImpl[F](
      protocol,
      columns,
      records,
      serverVariables,
      version,
      isClosed,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts,
      ResultSet.TYPE_FORWARD_ONLY
    )

  def empty[F[_]: MonadThrow](
    protocol:           Protocol[F],
    serverVariables:    Map[String, String],
    version:            Version,
    isClosed:           Ref[F, Boolean],
    fetchSize:          Ref[F, Int],
    useCursorFetch:     Boolean,
    useServerPrepStmts: Boolean
  ): ResultSetImpl[F] =
    this.apply[F](
      protocol,
      Vector.empty,
      Vector.empty,
      serverVariables,
      version,
      isClosed,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts
    )
