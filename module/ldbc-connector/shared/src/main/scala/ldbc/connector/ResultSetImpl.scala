/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector

import java.time.*
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import java.time.temporal.TemporalAccessor

import cats.syntax.all.*

import ldbc.sql.{ ResultSet, ResultSetMetaData }

import ldbc.connector.data.Formatter.*
import ldbc.connector.exception.SQLException
import ldbc.connector.net.packet.response.*
import ldbc.connector.util.Version

/**
 * A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
 */
private[ldbc] case class ResultSetImpl(
  columns:              Vector[ColumnDefinitionPacket],
  records:              Vector[ResultSetRowPacket],
  serverVariables:      Map[String, String],
  version:              Version,
  resultSetType:        Int            = ResultSet.TYPE_FORWARD_ONLY,
  resultSetConcurrency: Int            = ResultSet.CONCUR_READ_ONLY,
  statement:            Option[String] = None
) extends ResultSet:

  private final var isClosed:               Boolean                    = false
  private final var lastColumnReadNullable: Boolean                    = false
  private final var currentCursor:          Int                        = 0
  private final var currentRow:             Option[ResultSetRowPacket] = records.headOption

  def next(): Boolean =
    checkClose {
      if currentCursor <= records.size then
        currentRow    = records.lift(currentCursor)
        currentCursor = currentCursor + 1
        currentRow.isDefined
      else
        currentCursor = currentCursor + 1
        false
    }

  override def close(): Unit = isClosed = true

  override def wasNull(): Boolean = lastColumnReadNullable

  override def getString(columnIndex: Int): String =
    checkClose {
      rowDecode[String](columnIndex, _.toString) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getBoolean(columnIndex: Int): Boolean =
    checkClose {
      rowDecode[Boolean](
        columnIndex,
        {
          case "true" | "1"  => true
          case "false" | "0" => false
          case unknown       => raiseError(s"Unknown boolean value: $unknown")
        }
      ) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          false
    }

  override def getByte(columnIndex: Int): Byte =
    checkClose {
      rowDecode[Byte](columnIndex, _.toByte) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0
    }

  override def getShort(columnIndex: Int): Short =
    checkClose {
      rowDecode[Short](columnIndex, _.toShort) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0
    }

  override def getInt(columnIndex: Int): Int =
    checkClose {
      rowDecode[Int](columnIndex, _.toInt) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0
    }

  override def getLong(columnIndex: Int): Long =
    checkClose {
      rowDecode[Long](columnIndex, _.toLong) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0L
    }

  override def getFloat(columnIndex: Int): Float =
    checkClose {
      rowDecode[Float](columnIndex, _.toFloat) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0f
    }

  override def getDouble(columnIndex: Int): Double =
    checkClose {
      rowDecode[Double](columnIndex, _.toDouble) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          0.toDouble
    }

  override def getBytes(columnIndex: Int): Array[Byte] =
    checkClose {
      rowDecode[Array[Byte]](columnIndex, _.getBytes("UTF-8")) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getDate(columnIndex: Int): LocalDate =
    checkClose {
      rowDecodeEither[LocalDate](
        columnIndex,
        str => ResultSetImpl.temporalDecode[LocalDate](str)(localDateFormatter, LocalDate.parse)
      ) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getTime(columnIndex: Int): LocalTime =
    checkClose {
      rowDecodeEither[LocalTime](
        columnIndex,
        str => ResultSetImpl.temporalDecode[LocalTime](str)(timeFormatter(0), LocalTime.parse)
      ) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getTimestamp(columnIndex: Int): LocalDateTime =
    checkClose {
      rowDecodeEither[LocalDateTime](
        columnIndex,
        str => ResultSetImpl.temporalDecode[LocalDateTime](str)(localDateTimeFormatter(0), LocalDateTime.parse)
      ) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getString(columnLabel: String): String =
    checkClose {
      val index = findByName(columnLabel)
      getString(index + 1)
    }

  override def getBoolean(columnLabel: String): Boolean =
    checkClose {
      val index = findByName(columnLabel)
      getBoolean(index + 1)
    }

  override def getByte(columnLabel: String): Byte =
    checkClose {
      val index = findByName(columnLabel)
      getByte(index + 1)
    }

  override def getShort(columnLabel: String): Short =
    checkClose {
      val index = findByName(columnLabel)
      getShort(index + 1)
    }

  override def getInt(columnLabel: String): Int =
    checkClose {
      val index = findByName(columnLabel)
      getInt(index + 1)
    }

  override def getLong(columnLabel: String): Long =
    checkClose {
      val index = findByName(columnLabel)
      getLong(index + 1)
    }

  override def getFloat(columnLabel: String): Float =
    checkClose {
      val index = findByName(columnLabel)
      getFloat(index + 1)
    }

  override def getDouble(columnLabel: String): Double =
    checkClose {
      val index = findByName(columnLabel)
      getDouble(index + 1)
    }

  override def getBytes(columnLabel: String): Array[Byte] =
    checkClose {
      val index = findByName(columnLabel)
      getBytes(index + 1)
    }

  override def getDate(columnLabel: String): LocalDate =
    checkClose {
      val index = findByName(columnLabel)
      getDate(index + 1)
    }

  override def getTime(columnLabel: String): LocalTime =
    checkClose {
      val index = findByName(columnLabel)
      getTime(index + 1)
    }

  override def getTimestamp(columnLabel: String): LocalDateTime =
    checkClose {
      val index = findByName(columnLabel)
      getTimestamp(index + 1)
    }

  override def getMetaData(): ResultSetMetaData =
    checkClose {
      ResultSetMetaDataImpl(columns, serverVariables, version)
    }

  override def getBigDecimal(columnIndex: Int): BigDecimal =
    checkClose {
      rowDecode[BigDecimal](columnIndex, str => BigDecimal(str)) match
        case Some(value) =>
          lastColumnReadNullable = false
          value
        case None =>
          lastColumnReadNullable = true
          null
    }

  override def getBigDecimal(columnLabel: String): BigDecimal =
    checkClose {
      val index = findByName(columnLabel)
      getBigDecimal(index + 1)
    }

  override def isBeforeFirst(): Boolean =
    currentCursor <= 0 && records.nonEmpty

  override def isAfterLast(): Boolean =
    currentCursor > records.size && records.nonEmpty

  override def isFirst(): Boolean =
    currentCursor > 0

  override def isLast(): Boolean =
    currentCursor == records.size

  override def beforeFirst(): Unit =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else currentCursor = 0

  override def afterLast(): Unit =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else currentCursor = records.size + 1

  override def first(): Boolean =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else
      currentCursor = 1
      currentRow    = records.headOption
      currentRow.isDefined && records.nonEmpty

  override def last(): Boolean =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else
      currentCursor = records.size
      currentRow    = records.lastOption
      currentRow.isDefined && records.nonEmpty

  override def getRow(): Int =
    if currentCursor > records.size then 0
    else currentCursor

  override def absolute(row: Int): Boolean =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else if row > 0 then
      currentCursor = row
      currentRow    = records.lift(row - 1)
      row >= 1 && row <= records.size
    else if row < 0 then
      val position = records.size + row + 1
      currentCursor = position
      currentRow    = records.lift(records.size + row)
      position >= 1 && position <= records.size
    else
      currentCursor = 0
      currentRow    = None
      false

  override def relative(rows: Int): Boolean =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else
      val position = currentCursor + rows
      if position >= 1 && position <= records.size then
        currentCursor = position
        currentRow    = records.lift(position - 1)
        true
      else
        currentCursor = 0
        currentRow    = records.lift(currentCursor)
        false

  override def previous(): Boolean =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      raiseError("Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.")
    else if currentCursor > 0 then
      currentCursor = currentCursor - 1
      currentRow    = records.lift(currentCursor - 1)
      currentRow.isDefined
    else
      currentCursor = 0
      currentRow    = None
      false

  override def getType(): Int =
    checkClose {
      resultSetType
    }

  override def getConcurrency(): Int =
    checkClose {
      resultSetConcurrency
    }

  /**
   * Does the result set contain rows, or is it the result of a DDL or DML statement?
   *
   * @return true if result set contains rows
   */
  def hasRows(): Boolean =
    checkClose {
      records.nonEmpty
    }

  /**
   * Returns the number of rows in this <code>ResultSet</code> object.
   *
   * @return
   *   the number of rows
   */
  def rowLength(): Int =
    checkClose {
      records.size
    }

  private def checkClose[T](f: => T): T =
    if isClosed then raiseError("Operation not allowed after ResultSet closed")
    else f

  private def rowDecode[T](index: Int, decode: String => T): Option[T] =
    for
      row   <- currentRow
      value <- row.values(index - 1)
      decoded <- try { Option(decode(value.toByteVector.decodeUtf8Lenient)) }
                 catch case _ => None
    yield decoded

  private def rowDecodeEither[T](index: Int, decode: String => Either[String, T]): Option[T] =
    for
      row     <- currentRow
      value   <- row.values(index - 1)
      decoded <- decode(value.toByteVector.decodeUtf8Lenient).toOption
    yield decoded

  private def findByName(columnLabel: String): Int =
    columns.zipWithIndex
      .find { (column: ColumnDefinitionPacket, _) =>
        column.name.equalsIgnoreCase(columnLabel) || column.fullName.equalsIgnoreCase(columnLabel)
      }
      .map(_._2)
      .getOrElse(
        raiseError(
          s"${ Console.CYAN }Column name '${ Console.RED }$columnLabel${ Console.CYAN }' does not exist in the ResultSet."
        )
      )

  private def raiseError[T](message: String): T =
    throw new SQLException(message, sql = statement)

private[ldbc] object ResultSetImpl:

  private[ldbc] def temporalDecode[A <: TemporalAccessor](str: String)(
    formatter: DateTimeFormatter,
    parse:     (String, DateTimeFormatter) => A
  ): Either[String, A] =
    Either.catchOnly[DateTimeParseException](parse(str, formatter)).leftMap(_.getMessage)

  def apply(
    columns:         Vector[ColumnDefinitionPacket],
    records:         Vector[ResultSetRowPacket],
    serverVariables: Map[String, String],
    version:         Version
  ): ResultSetImpl =
    ResultSetImpl(
      columns,
      records,
      serverVariables,
      version,
      ResultSet.TYPE_FORWARD_ONLY
    )

  def empty(
    serverVariables: Map[String, String],
    version:         Version
  ): ResultSetImpl =
    this.apply(
      Vector.empty,
      Vector.empty,
      serverVariables,
      version
    )
