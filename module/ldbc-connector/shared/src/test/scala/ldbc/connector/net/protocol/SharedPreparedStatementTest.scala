/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.net.protocol

import java.time.*

import scala.collection.immutable.SortedMap

import cats.effect.{ IO, Ref }

import ldbc.sql.ResultSet

import ldbc.connector.data.*
import ldbc.connector.exception.SQLException
import ldbc.connector.FTestPlatform

class SharedPreparedStatementTest extends SharedPreparedStatement[IO], FTestPlatform:

  private val parameterMap = SortedMap.empty[Int, Parameter]
  override val params: Ref[IO, SortedMap[Int, Parameter]] = Ref.unsafe[IO, SortedMap[Int, Parameter]](parameterMap)

  // Implementation of required members from StatementImpl.ShareStatement
  override val autoGeneratedKeys: Ref[IO, Int]                   = Ref.unsafe[IO, Int](0)
  override val connectionClosed:  Ref[IO, Boolean]               = Ref.unsafe[IO, Boolean](false)
  override val currentResultSet:  Ref[IO, Option[ResultSet[IO]]] = Ref.unsafe[IO, Option[ResultSet[IO]]](None)
  override val lastInsertId:      Ref[IO, Long]                  = Ref.unsafe[IO, Long](0L)
  override val moreResults:       Ref[IO, Boolean]               = Ref.unsafe[IO, Boolean](false)
  override val statementClosed:   Ref[IO, Boolean]               = Ref.unsafe[IO, Boolean](false)
  override val updateCount:       Ref[IO, Long]                  = Ref.unsafe[IO, Long](0L)

  override def fetchSize:      Ref[IO, Int] = Ref.unsafe[IO, Int](0)
  override def useCursorFetch: Boolean      = false
  override def resultSetType:  Int          = ResultSet.TYPE_FORWARD_ONLY

  // Implementation of required methods from Statement
  override def clearBatch():       IO[Unit]          = IO.unit
  override def getGeneratedKeys(): IO[ResultSet[IO]] =
    IO.raiseError(new UnsupportedOperationException("Not implemented for test"))

  // Helper method to reset parameters
  private def resetParams: IO[Unit] = params.set(SortedMap.empty[Int, Parameter])

  // Helper method to compare Parameter instances
  private def assertParameter(actual: Parameter, expected: Parameter): Boolean = {
    actual.sql == expected.sql &&
    actual.columnDataType == expected.columnDataType
  }

  // Helper method to compare SortedMaps containing Parameters
  private def assertParameters(actual: SortedMap[Int, Parameter], expected: SortedMap[Int, Parameter]): IO[Unit] = {
    IO {
      // Check if key sets match
      assertEquals(actual.keySet, expected.keySet)

      // Compare Parameter values for each key
      actual.keys.foreach { key =>
        val actualParam   = actual(key)
        val expectedParam = expected(key)
        assert(
          assertParameter(actualParam, expectedParam),
          s"Parameter at index $key did not match: actual=$actualParam, expected=$expectedParam"
        )
      }
    }
  }

  test("setNull should set a null parameter") {
    for {
      _      <- resetParams
      _      <- setNull(1, 0)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.none))
    } yield ()
  }

  test("setBoolean should set a boolean parameter") {
    for {
      _      <- resetParams
      _      <- setBoolean(1, true)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.boolean(true)))
    } yield ()
  }

  test("setByte should set a byte parameter") {
    for {
      _      <- resetParams
      _      <- setByte(1, 5.toByte)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.byte(5.toByte)))
    } yield ()
  }

  test("setShort should set a short parameter") {
    for {
      _      <- resetParams
      _      <- setShort(1, 10.toShort)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.short(10.toShort)))
    } yield ()
  }

  test("setInt should set an int parameter") {
    for {
      _      <- resetParams
      _      <- setInt(1, 100)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.int(100)))
    } yield ()
  }

  test("setLong should set a long parameter") {
    for {
      _      <- resetParams
      _      <- setLong(1, 1000L)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.long(1000L)))
    } yield ()
  }

  test("setFloat should set a float parameter") {
    for {
      _      <- resetParams
      _      <- setFloat(1, 10.5f)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.float(10.5f)))
    } yield ()
  }

  test("setDouble should set a double parameter") {
    for {
      _      <- resetParams
      _      <- setDouble(1, 20.75)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.double(20.75)))
    } yield ()
  }

  test("setBigDecimal should set a BigDecimal parameter") {
    val bd = BigDecimal("123456.789")
    for {
      _      <- resetParams
      _      <- setBigDecimal(1, bd)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.bigDecimal(bd)))
    } yield ()
  }

  test("setString should set a string parameter") {
    for {
      _      <- resetParams
      _      <- setString(1, "test")
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.string("test")))
    } yield ()
  }

  test("setBytes should set a bytes parameter") {
    val bytes = "hello".getBytes
    for {
      _      <- resetParams
      _      <- setBytes(1, bytes)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.bytes(bytes)))
    } yield ()
  }

  test("setTime should set a time parameter") {
    val time = LocalTime.of(10, 30, 15)
    for {
      _      <- resetParams
      _      <- setTime(1, time)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.time(time)))
    } yield ()
  }

  test("setDate should set a date parameter") {
    val date = LocalDate.of(2023, 5, 10)
    for {
      _      <- resetParams
      _      <- setDate(1, date)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.date(date)))
    } yield ()
  }

  test("setTimestamp should set a timestamp parameter") {
    val timestamp = LocalDateTime.of(2023, 5, 10, 10, 30, 15)
    for {
      _      <- resetParams
      _      <- setTimestamp(1, timestamp)
      result <- params.get
      _      <- assertParameters(result, SortedMap(1 -> Parameter.datetime(timestamp)))
    } yield ()
  }

  test("setObject should set the correct parameter based on object type") {
    for {
      _       <- resetParams
      _       <- setObject(1, "test string".asInstanceOf[Object])
      result1 <- params.get
      _       <- assertParameters(result1, SortedMap(1 -> Parameter.string("test string")))

      _       <- resetParams
      _       <- setObject(1, 42L.asInstanceOf[Object])
      result2 <- params.get
      _       <- assertParameters(result2, SortedMap(1 -> Parameter.long(42L)))

      _       <- resetParams
      _       <- setObject(1, null)
      result3 <- params.get
      _       <- assertParameters(result3, SortedMap(1 -> Parameter.none))
    } yield ()
  }

  test("setObject should throw SQLException for unsupported types") {
    interceptIO[SQLException](setObject(1, new Object()))
  }

  test("buildQuery should replace placeholders with parameter values") {
    for {
      _      <- resetParams
      _      <- setInt(1, 100)
      _      <- setString(2, "John")
      result <- params.get.map(p => buildQuery("SELECT * FROM users WHERE id = ? AND name = ?", p))
      _      <- IO(assertEquals(result, "SELECT * FROM users WHERE id = 100 AND name = 'John'"))
    } yield ()
  }

  test("buildBatchQuery should handle INSERT statements correctly") {
    for {
      _      <- resetParams
      _      <- setInt(1, 100)
      _      <- setString(2, "John")
      result <- params.get.map(p => buildBatchQuery("INSERT INTO users (id, name) VALUES (?, ?)", p))
      _      <- IO(assertEquals(result, " (100, 'John')"))
    } yield ()
  }

  test("buildBatchQuery should handle UPDATE statements correctly") {
    for {
      _      <- resetParams
      _      <- setString(1, "John")
      _      <- setInt(2, 100)
      result <- params.get.map(p => buildBatchQuery("UPDATE users SET name = ? WHERE id = ?", p))
      _      <- IO(assertEquals(result, "UPDATE users SET name = 'John' WHERE id = 100"))
    } yield ()
  }

  test("buildBatchQuery should throw exception for non-DML statements") {
    for {
      _      <- resetParams
      _      <- setInt(1, 100)
      params <- params.get
      result <- IO.delay(buildBatchQuery("SELECT * FROM users WHERE id = ?", params)).attempt
      _      <- IO(
             assert(
               result.isLeft && result.left.exists(
                 _.getMessage == "The batch query must be an INSERT, UPDATE, or DELETE statement."
               )
             )
           )
    } yield ()
  }

  override def executeQuery(): IO[ResultSet[IO]] =
    IO.raiseError(new UnsupportedOperationException("Not implemented for test"))

  override def executeLargeUpdate(): IO[Long] = IO.pure(0L)

  override def execute(): IO[Boolean] = IO.pure(false)

  override def addBatch(): IO[Unit] = IO.unit

  override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty[Long])

  override def close(): IO[Unit] = IO.unit
