/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.pool

import scala.concurrent.duration.*

import cats.effect.*
import cats.effect.std.Console

import org.typelevel.otel4s.trace.Tracer

import ldbc.sql.*

import ldbc.connector.{ Connection as LdbcConnection, * }

class ProxyConnectionTest extends FTestPlatform:

  given Tracer[IO] = Tracer.noop[IO]

  def connection: Resource[IO, LdbcConnection[IO]] = LdbcConnection[IO](
    host     = TestConfig.host,
    port     = TestConfig.port,
    user     = TestConfig.user,
    password = Some(TestConfig.password),
    database = Some("connector_test"),
    ssl      = SSL.Trusted
  )

  // Helper to create a pooled connection
  def createPooledConnection(id: String, conn: LdbcConnection[IO]): IO[PooledConnection[IO]] =
    for
      currentTime      <- IO.realTime.map(_.toMillis)
      stateRef         <- Ref[IO].of[ConnectionState](ConnectionState.Idle)
      lastUsedRef      <- Ref[IO].of(currentTime)
      useCountRef      <- Ref[IO].of(0L)
      lastValidatedRef <- Ref[IO].of(currentTime)
      leakDetectionRef <- Ref[IO].of(Option.empty[Fiber[IO, Throwable, Unit]])
      bagStateRef      <- Ref[IO].of(BagEntry.STATE_NOT_IN_USE)
    yield PooledConnection[IO](
      id              = id,
      connection      = conn,
      finalizer       = IO.unit,
      state           = stateRef,
      createdAt       = currentTime,
      lastUsedAt      = lastUsedRef,
      useCount        = useCountRef,
      lastValidatedAt = lastValidatedRef,
      leakDetection   = leakDetectionRef,
      bagState        = bagStateRef
    )

  test("ProxyConnection should track created statements") {
    connection.use { conn =>
      for
        pooledConn      <- createPooledConnection("test-1", conn)
        callbackInvoked <- Ref[IO].of(false)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => callbackInvoked.set(true),
                  closeAllStatements = true
                )

        // Create multiple statements
        stmt1 <- proxy.createStatement()
        stmt2 <- proxy.createStatement()
        stmt3 <- proxy.createStatement()

        // Close the proxy connection
        _ <- proxy.close()

        wasInvoked <- callbackInvoked.get
      yield assert(wasInvoked, "Release callback should have been invoked")
    }
  }

  test("ProxyConnection should close all tracked statements on close when closeAllStatements is true") {
    connection.use { conn =>
      for
        pooledConn  <- createPooledConnection("test-1", conn)
        closedStmts <- Ref[IO].of(List.empty[String])

        // Mock statement that tracks close calls
        mockStmt = new Statement[IO] {
                     override def close():                   IO[Unit]          = closedStmts.update(_ :+ "stmt")
                     override def execute(sql: String):      IO[Boolean]       = IO.pure(false)
                     override def executeQuery(sql: String): IO[ResultSet[IO]] =
                       IO.raiseError(new UnsupportedOperationException)
                     override def executeUpdate(sql: String): IO[Int]                   = IO.pure(0)
                     override def getResultSet():             IO[Option[ResultSet[IO]]] = IO.pure(None)
                     override def getUpdateCount():           IO[Int]                   = IO.pure(0)
                     override def getMoreResults():           IO[Boolean]               = IO.pure(false)
                     override def setFetchSize(rows: Int):    IO[Unit]                  = IO.unit
                     override def getFetchSize():             IO[Int]                   = IO.pure(0)
                     override def addBatch(sql:      String): IO[Unit]                  = IO.unit
                     override def clearBatch():               IO[Unit]                  = IO.unit
                     override def executeBatch():             IO[Array[Int]]            = IO.pure(Array.empty)
                     override def getGeneratedKeys():         IO[ResultSet[IO]]         =
                       IO.raiseError(new UnsupportedOperationException)
                     override def executeUpdate(sql:      String, autoGeneratedKeys: Int): IO[Int]     = IO.pure(0)
                     override def execute(sql:            String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
                     override def isClosed():                                              IO[Boolean] = IO.pure(false)
                     override def getLargeUpdateCount():                                   IO[Long]    = IO.pure(0L)
                     override def executeLargeUpdate(sql: String):                         IO[Long]    = IO.pure(0L)
                     override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long]    = IO.pure(0L)
                     override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
                   }

        // Create a custom connection that returns our mock statements
        customConn = new LdbcConnection[IO] {
                       // Delegate most methods to the real connection
                       override def createStatement():             IO[Statement[IO]]         = IO.pure(mockStmt)
                       override def close():                       IO[Unit]                  = conn.close()
                       override def isClosed():                    IO[Boolean]               = conn.isClosed()
                       override def prepareStatement(sql: String): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql)
                       override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
                       override def nativeSQL(sql:   String): IO[String]                = conn.nativeSQL(sql)
                       override def setAutoCommit(autoCommit: Boolean): IO[Unit]    = conn.setAutoCommit(autoCommit)
                       override def getAutoCommit():                    IO[Boolean] = conn.getAutoCommit()
                       override def commit():                           IO[Unit]    = conn.commit()
                       override def rollback():                         IO[Unit]    = conn.rollback()
                       override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
                       override def setReadOnly(readOnly: Boolean): IO[Unit]    = conn.setReadOnly(readOnly)
                       override def isReadOnly:                     IO[Boolean] = conn.isReadOnly
                       override def setCatalog(catalog:   String):  IO[Unit]    = conn.setCatalog(catalog)
                       override def getCatalog():                   IO[String]  = conn.getCatalog()
                       override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
                       override def getTransactionIsolation():           IO[Int]  = conn.getTransactionIsolation()
                       override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] =
                         IO.pure(mockStmt)
                       override def prepareStatement(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
                       override def prepareCall(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
                       override def setSavepoint():                 IO[Savepoint] = conn.setSavepoint()
                       override def setSavepoint(name:  String):    IO[Savepoint] = conn.setSavepoint(name)
                       override def rollback(savepoint: Savepoint): IO[Unit]      = conn.rollback(savepoint)
                       override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
                       override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql, autoGeneratedKeys)
                       override def setSchema(schema: String): IO[Unit]    = conn.setSchema(schema)
                       override def getSchema():               IO[String]  = conn.getSchema()
                       override def isValid(timeout:  Int):    IO[Boolean] = conn.isValid(timeout)
                     }

        customPooledConn <- createPooledConnection("test-2", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statements through proxy
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()

        // Close should close all statements
        _ <- proxy.close()

        closed <- closedStmts.get
      yield assertEquals(closed.length, 3, "All 3 statements should have been closed")
    }
  }

  test("ProxyConnection should not close statements when closeAllStatements is false") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        stmtClosed <- Ref[IO].of(false)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = false
                )

        // Create a statement and execute query
        stmt <- proxy.createStatement()
        _    <- stmt.executeQuery("SELECT 1").attempt // Attempt to handle any errors

        // Close proxy - statements should not be closed
        _ <- proxy.close()

        // Verify we can still use the statement (would fail if closed)
        canExecute <- stmt.executeQuery("SELECT 1").attempt.map(_.isRight)
      yield assert(canExecute, "Statement should still be usable after proxy close")
    }
  }

  test("ProxyConnection should track prepared statements") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create prepared statements
        pstmt1 <- proxy.prepareStatement("SELECT ?")
        pstmt2 <- proxy.prepareStatement(
                    "SELECT ? + ?",
                    java.sql.ResultSet.TYPE_FORWARD_ONLY,
                    java.sql.ResultSet.CONCUR_READ_ONLY
                  )
        pstmt3 <- proxy.prepareStatement("INSERT INTO test VALUES (?)", java.sql.Statement.RETURN_GENERATED_KEYS)

        // Use the statements
        _ <- pstmt1.setInt(1, 42)
        _ <- pstmt2.setInt(1, 10)
        _ <- pstmt2.setInt(2, 20)
        _ <- pstmt3.setString(1, "test")

        // Close proxy
        _ <- proxy.close()
      yield assert(true, "Prepared statements should be tracked and closed")
    }
  }

  test("ProxyConnection should track callable statements") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Try to create callable statements (may fail if stored procedures don't exist)
        cstmt1Result <- proxy.prepareCall("CALL test_proc()").attempt
        cstmt2Result <-
          proxy
            .prepareCall("CALL test_proc2()", java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY)
            .attempt

        // Close proxy
        _ <- proxy.close()
      yield assert(true, "Callable statements should be tracked if created")
    }
  }

  test("ProxyConnection should handle statement close errors gracefully") {
    connection.use { conn =>
      for
        pooledConn  <- createPooledConnection("test-1", conn)
        errorLogged <- Ref[IO].of(false)

        // Mock statement that throws on close
        errorStmt = new Statement[IO] {
                      override def close(): IO[Unit] = IO.raiseError(new RuntimeException("Close failed"))
                      override def execute(sql: String):      IO[Boolean]       = IO.pure(false)
                      override def executeQuery(sql: String): IO[ResultSet[IO]] =
                        IO.raiseError(new UnsupportedOperationException)
                      override def executeUpdate(sql: String): IO[Int]                   = IO.pure(0)
                      override def getResultSet():             IO[Option[ResultSet[IO]]] = IO.pure(None)
                      override def getUpdateCount():           IO[Int]                   = IO.pure(0)
                      override def getMoreResults():           IO[Boolean]               = IO.pure(false)
                      override def setFetchSize(rows: Int):    IO[Unit]                  = IO.unit
                      override def getFetchSize():             IO[Int]                   = IO.pure(0)
                      override def addBatch(sql:      String): IO[Unit]                  = IO.unit
                      override def clearBatch():               IO[Unit]                  = IO.unit
                      override def executeBatch():             IO[Array[Int]]            = IO.pure(Array.empty)
                      override def getGeneratedKeys():         IO[ResultSet[IO]]         =
                        IO.raiseError(new UnsupportedOperationException)
                      override def executeUpdate(sql:      String, autoGeneratedKeys: Int): IO[Int]     = IO.pure(0)
                      override def execute(sql:            String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
                      override def isClosed():                                              IO[Boolean] = IO.pure(false)
                      override def getLargeUpdateCount():                                   IO[Long]    = IO.pure(0L)
                      override def executeLargeUpdate(sql: String):                         IO[Long]    = IO.pure(0L)
                      override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long]    = IO.pure(0L)
                      override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
                    }

        // Custom console that tracks error messages
        given Console[IO] = new Console[IO] {
                              def readLineWithCharset(charset: java.nio.charset.Charset):    IO[String] = IO.pure("")
                              def print[A](a:                  A)(implicit S: cats.Show[A]): IO[Unit]   = IO.unit
                              def println[A](a:                A)(implicit S: cats.Show[A]): IO[Unit]   = IO.unit
                              def error[A](a:                  A)(implicit S: cats.Show[A]): IO[Unit]   = IO.unit
                              def errorln[A](a: A)(implicit S: cats.Show[A]):                IO[Unit]   =
                                if S.show(a).contains("Error closing statement") then errorLogged.set(true)
                                else IO.unit
                            }

        // Create custom connection that returns error statements
        customConn = new LdbcConnection[IO] {
                       override def createStatement():             IO[Statement[IO]]         = IO.pure(errorStmt)
                       override def close():                       IO[Unit]                  = conn.close()
                       override def isClosed():                    IO[Boolean]               = conn.isClosed()
                       override def prepareStatement(sql: String): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql)
                       override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
                       override def nativeSQL(sql:   String): IO[String]                = conn.nativeSQL(sql)
                       override def setAutoCommit(autoCommit: Boolean): IO[Unit]    = conn.setAutoCommit(autoCommit)
                       override def getAutoCommit():                    IO[Boolean] = conn.getAutoCommit()
                       override def commit():                           IO[Unit]    = conn.commit()
                       override def rollback():                         IO[Unit]    = conn.rollback()
                       override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
                       override def setReadOnly(readOnly: Boolean): IO[Unit]    = conn.setReadOnly(readOnly)
                       override def isReadOnly:                     IO[Boolean] = conn.isReadOnly
                       override def setCatalog(catalog:   String):  IO[Unit]    = conn.setCatalog(catalog)
                       override def getCatalog():                   IO[String]  = conn.getCatalog()
                       override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
                       override def getTransactionIsolation():           IO[Int]  = conn.getTransactionIsolation()
                       override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] =
                         IO.pure(errorStmt)
                       override def prepareStatement(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
                       override def prepareCall(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
                       override def setSavepoint():                 IO[Savepoint] = conn.setSavepoint()
                       override def setSavepoint(name:  String):    IO[Savepoint] = conn.setSavepoint(name)
                       override def rollback(savepoint: Savepoint): IO[Unit]      = conn.rollback(savepoint)
                       override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
                       override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql, autoGeneratedKeys)
                       override def setSchema(schema: String): IO[Unit]    = conn.setSchema(schema)
                       override def getSchema():               IO[String]  = conn.getSchema()
                       override def isValid(timeout:  Int):    IO[Boolean] = conn.isValid(timeout)
                     }

        customPooledConn <- createPooledConnection("test-3", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statement that will fail to close
        _ <- proxy.createStatement()

        // Close should handle the error gracefully
        _ <- proxy.close()

        wasErrorLogged <- errorLogged.get
      yield assert(wasErrorLogged, "Error should have been logged")
    }
  }

  test("ProxyConnection should delegate all connection operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        // Test various delegated operations
        _          <- proxy.setAutoCommit(false)
        autoCommit <- proxy.getAutoCommit()

        catalog <- proxy.getCatalog()
        schema  <- proxy.getSchema()

        isolation <- proxy.getTransactionIsolation()
        _         <- proxy.setTransactionIsolation(java.sql.Connection.TRANSACTION_READ_COMMITTED)

        isValid  <- proxy.isValid(5)
        isClosed <- proxy.isClosed()

        metadata <- proxy.getMetaData()

        _ <- proxy.setAutoCommit(true)
      yield
        assert(!autoCommit, "Auto-commit should be false")
        assert(catalog != null, "Catalog should not be null")
        assert(isValid, "Connection should be valid")
        assert(!isClosed, "Connection should not be closed")
        assert(metadata != null, "Metadata should not be null")
    }
  }

  test("ProxyConnection should support transaction operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        _ <- proxy.setAutoCommit(false)

        // Create and use a statement
        stmt <- proxy.createStatement()
        _    <- stmt.executeUpdate("CREATE TEMPORARY TABLE test_proxy_tx (id INT)")
        _    <- stmt.executeUpdate("INSERT INTO test_proxy_tx VALUES (1), (2), (3)")

        // Commit the transaction
        _ <- proxy.commit()

        // Verify data was committed
        rs    <- stmt.executeQuery("SELECT COUNT(*) FROM test_proxy_tx")
        _     <- rs.next()
        count <- rs.getInt(1)

        _ <- proxy.setAutoCommit(true)
      yield assertEquals(count, 3, "Should have 3 rows after commit")
    }
  }

  test("ProxyConnection should support savepoint operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        _ <- proxy.setAutoCommit(false)

        stmt <- proxy.createStatement()
        _    <- stmt.executeUpdate("CREATE TEMPORARY TABLE test_proxy_sp (id INT)")

        // Insert first row
        _ <- stmt.executeUpdate("INSERT INTO test_proxy_sp VALUES (1)")

        // Create savepoint
        sp <- proxy.setSavepoint("sp1")

        // Insert second row
        _ <- stmt.executeUpdate("INSERT INTO test_proxy_sp VALUES (2)")

        // Rollback to savepoint
        _ <- proxy.rollback(sp)

        // Release savepoint
        _ <- proxy.releaseSavepoint(sp)

        // Commit
        _ <- proxy.commit()

        // Check results
        rs    <- stmt.executeQuery("SELECT COUNT(*) FROM test_proxy_sp")
        _     <- rs.next()
        count <- rs.getInt(1)

        _ <- proxy.setAutoCommit(true)
      yield assertEquals(count, 1, "Should have only 1 row after rollback to savepoint")
    }
  }

  test("ProxyConnection should clear statement list after close") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        closeCount <- Ref[IO].of(0)

        // Mock statement that counts close calls
        mockStmt = new Statement[IO] {
                     override def close():                   IO[Unit]          = closeCount.update(_ + 1)
                     override def execute(sql: String):      IO[Boolean]       = IO.pure(false)
                     override def executeQuery(sql: String): IO[ResultSet[IO]] =
                       IO.raiseError(new UnsupportedOperationException)
                     override def executeUpdate(sql: String): IO[Int]                   = IO.pure(0)
                     override def getResultSet():             IO[Option[ResultSet[IO]]] = IO.pure(None)
                     override def getUpdateCount():           IO[Int]                   = IO.pure(0)
                     override def getMoreResults():           IO[Boolean]               = IO.pure(false)
                     override def setFetchSize(rows: Int):    IO[Unit]                  = IO.unit
                     override def getFetchSize():             IO[Int]                   = IO.pure(0)
                     override def addBatch(sql:      String): IO[Unit]                  = IO.unit
                     override def clearBatch():               IO[Unit]                  = IO.unit
                     override def executeBatch():             IO[Array[Int]]            = IO.pure(Array.empty)
                     override def getGeneratedKeys():         IO[ResultSet[IO]]         =
                       IO.raiseError(new UnsupportedOperationException)
                     override def executeUpdate(sql:      String, autoGeneratedKeys: Int): IO[Int]     = IO.pure(0)
                     override def execute(sql:            String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
                     override def isClosed():                                              IO[Boolean] = IO.pure(false)
                     override def getLargeUpdateCount():                                   IO[Long]    = IO.pure(0L)
                     override def executeLargeUpdate(sql: String):                         IO[Long]    = IO.pure(0L)
                     override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long]    = IO.pure(0L)
                     override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
                   }

        customConn = new LdbcConnection[IO] {
                       override def createStatement():             IO[Statement[IO]]         = IO.pure(mockStmt)
                       override def close():                       IO[Unit]                  = conn.close()
                       override def isClosed():                    IO[Boolean]               = conn.isClosed()
                       override def prepareStatement(sql: String): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql)
                       override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
                       override def nativeSQL(sql:   String): IO[String]                = conn.nativeSQL(sql)
                       override def setAutoCommit(autoCommit: Boolean): IO[Unit]    = conn.setAutoCommit(autoCommit)
                       override def getAutoCommit():                    IO[Boolean] = conn.getAutoCommit()
                       override def commit():                           IO[Unit]    = conn.commit()
                       override def rollback():                         IO[Unit]    = conn.rollback()
                       override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
                       override def setReadOnly(readOnly: Boolean): IO[Unit]    = conn.setReadOnly(readOnly)
                       override def isReadOnly:                     IO[Boolean] = conn.isReadOnly
                       override def setCatalog(catalog:   String):  IO[Unit]    = conn.setCatalog(catalog)
                       override def getCatalog():                   IO[String]  = conn.getCatalog()
                       override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
                       override def getTransactionIsolation():           IO[Int]  = conn.getTransactionIsolation()
                       override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] =
                         IO.pure(mockStmt)
                       override def prepareStatement(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
                       override def prepareCall(
                         sql:                  String,
                         resultSetType:        Int,
                         resultSetConcurrency: Int
                       ): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
                       override def setSavepoint():                 IO[Savepoint] = conn.setSavepoint()
                       override def setSavepoint(name:  String):    IO[Savepoint] = conn.setSavepoint(name)
                       override def rollback(savepoint: Savepoint): IO[Unit]      = conn.rollback(savepoint)
                       override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
                       override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] =
                         conn.prepareStatement(sql, autoGeneratedKeys)
                       override def setSchema(schema: String): IO[Unit]    = conn.setSchema(schema)
                       override def getSchema():               IO[String]  = conn.getSchema()
                       override def isValid(timeout:  Int):    IO[Boolean] = conn.isValid(timeout)
                     }

        customPooledConn <- createPooledConnection("test-4", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statements
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()

        // First close
        _      <- proxy.close()
        count1 <- closeCount.get

        // Second close - statements should already be cleared
        _      <- proxy.close()
        count2 <- closeCount.get
      yield
        assertEquals(count1, 2, "First close should close 2 statements")
        assertEquals(count2, 2, "Second close should not close any additional statements")
    }
  }

  test("ProxyConnection should maintain pooled connection reference") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )
      yield
        assertEquals(proxy.pooled.id, "test-1")
        assertEquals(proxy.pooled, pooledConn)
    }
  }
