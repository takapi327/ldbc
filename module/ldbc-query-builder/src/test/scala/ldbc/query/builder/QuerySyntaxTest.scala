/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.query.builder

import org.scalatest.flatspec.AnyFlatSpec

class QuerySyntaxTest extends AnyFlatSpec:

  it should "It can be converted to the model specified by the toList method." in {
    assertCompiles(
      """
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query = user.selectAll.query.to[List]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the toList method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.queryTo[FailedUser].to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the toList method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query: DBIO[List[User]] = user.selectAll.query.to[List]
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the headOption method." in {
    assertCompiles(
      """
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query = user.selectAll.where(_.id === 1).query.to[Option]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the headOption method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |given Codec[FailedUser] = Codec.derived[FailedUser]
        |val query = user.selectAll.where(_.id === 1).queryTo[FailedUser].to[Option]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the headOption method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query: DBIO[Option[User]] = user.selectAll.where(_.id === 1).query.to[Option]
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the unsafe method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query: DBIO[User] = user.selectAll.where(_.id === 1).query.unsafe
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the unsafe method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |given Codec[FailedUser] = Codec.derived[FailedUser]
        |val query = user.selectAll.where(_.id === 1).query[FailedUser].unsafe
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the unsafe method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |val user = TableQuery[User]
        |
        |val query: DBIO[User] = user.selectAll.where(_.id === 1).query.unsafe
        |""".stripMargin
    )
  }

  it should "The type of the Tuple generated by the Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |case class Category(id: Long, name: String) derives Table
        |given Codec[Category] = Codec.derived[Category]
        |
        |val user = TableQuery[User]
        |val category = TableQuery[Category]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |given Codec[UserCategory] = Codec.derived[UserCategory]
        |
        |val query: DBIO[List[(String, String)]] = (user join category).on((user, category) => user.categoryId === category.id)
        |  .select((user, category) => user.name *: category.name)
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type generated by the join matches the type of the specified model." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long) derives Table
        |given Codec[User] = Codec.derived[User]
        |
        |case class Category(id: Long, name: String) derives Table
        |given Codec[Category] = Codec.derived[Category]
        |
        |val user = TableQuery[User]
        |val category = TableQuery[Category]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |given Codec[UserCategory] = Codec.derived[UserCategory]
        |
        |val query = (user join category).on((user, category) => user.categoryId === category.id)
        |  .select((user, category) => user.name *: category.name)
        |  .queryTo[UserCategory]
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Left Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class Country(code: String, name: String) derives Table
        |given Codec[Country] = Codec.derived[Country]
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |given Codec[City] = Codec.derived[City]
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |) derives Table
        |given Codec[CountryLanguage] = Codec.derived[CountryLanguage]
        |
        |val countryQuery = TableQuery[Country]
        |val cityQuery = TableQuery[City]
        |val countryLanguageQuery = TableQuery[CountryLanguage]
        |
        |val query: DBIO[List[(String, String, Option[String])]] = (countryQuery join cityQuery).on((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery).on((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => country.name *: city.name *: countryLanguage.language)
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Right Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class Country(code: String, name: String) derives Table
        |given Codec[Country] = Codec.derived[Country]
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |given Codec[City] = Codec.derived[City]
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |) derives Table
        |given Codec[CountryLanguage] = Codec.derived[CountryLanguage]
        |
        |val countryQuery = TableQuery[Country]
        |val cityQuery = TableQuery[City]
        |val countryLanguageQuery = TableQuery[CountryLanguage]
        |
        |val query: DBIO[List[(Option[String], Option[String], String)]] = (countryQuery join cityQuery).on((country, city) => country.code === city.countryCode)
        |  .rightJoin(countryLanguageQuery).on((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => country.name *: city.name *: countryLanguage.language)
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "When a column of type Option is made into type Option with Right Join, Option is not nested." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.DBIO
        |import ldbc.dsl.codec.Codec
        |import ldbc.query.builder.*
        |
        |case class Country(code: String, name: String) derives Table
        |given Codec[Country] = Codec.derived[Country]
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |given Codec[City] = Codec.derived[City]
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    Option[String]
        |) derives Table
        |given Codec[CountryLanguage] = Codec.derived[CountryLanguage]
        |
        |val countryQuery = TableQuery[Country]
        |val cityQuery = TableQuery[City]
        |val countryLanguageQuery = TableQuery[CountryLanguage]
        |
        |val query: DBIO[List[(String, String, Option[String])]] = (countryQuery join cityQuery).on((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery).on((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => country.name *: city.name *: countryLanguage.language)
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }
