<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>型安全なクエリ構築 · LDBC</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Documentation for ldbc'/>
<link rel="canonical" href="https://takapi327.github.io/ldbc/../ja/03-Type-safe-Query-Builder.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../ja/index.html" >
<span class="home-icon">⌂</span>LDBC
</a>
<div class="version-number">
0.3.0-alpha2
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../ja/01-Table-Definitions.html" class="page">テーブル定義</a></li>
  <li><a href="../ja/02-Custom-Data-Type.html" class="page">カスタム データ型</a></li>
  <li><a href="../ja/03-Type-safe-Query-Builder.html" class="active page">型安全なクエリ構築</a></li>
  <li><a href="../ja/04-Database-Connection.html" class="page">データベース接続</a></li>
  <li><a href="../ja/05-Plain-SQL-Queries.html" class="page">プレーンなSQLクエリ</a></li>
  <li><a href="../ja/06-Generating-SchemaSPY-Documentation.html" class="page">SchemaSPYドキュメントの生成</a></li>
  <li><a href="../ja/07-Schema-Code-Generation.html" class="page">スキーマコード生成</a></li>
  <li><a href="../ja/08-Perdormance.html" class="page">パフォーマンス</a></li>
  <li><a href="../ja/09-Connector.html" class="page">コネクタ</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../ja/index.html">LDBC</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../ja/index.html" >
<span class="home-icon">⌂</span>LDBC
</a>
<div class="version-number">
0.3.0-alpha2
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../ja/01-Table-Definitions.html" class="page">テーブル定義</a></li>
  <li><a href="../ja/02-Custom-Data-Type.html" class="page">カスタム データ型</a></li>
  <li><a href="../ja/03-Type-safe-Query-Builder.html" class="active page">型安全なクエリ構築</a></li>
  <li><a href="../ja/04-Database-Connection.html" class="page">データベース接続</a></li>
  <li><a href="../ja/05-Plain-SQL-Queries.html" class="page">プレーンなSQLクエリ</a></li>
  <li><a href="../ja/06-Generating-SchemaSPY-Documentation.html" class="page">SchemaSPYドキュメントの生成</a></li>
  <li><a href="../ja/07-Schema-Code-Generation.html" class="page">スキーマコード生成</a></li>
  <li><a href="../ja/08-Perdormance.html" class="page">パフォーマンス</a></li>
  <li><a href="../ja/09-Connector.html" class="page">コネクタ</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../ja/index.html">LDBC</a></li>
  <li>型安全なクエリ構築</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#型安全なクエリ構築" name="型安全なクエリ構築" class="anchor"><span class="anchor-link"></span></a>型安全なクエリ構築</h1>
<p>この章では、LDBCで構築したテーブル定義を使用して、型安全にクエリを構築するための方法について説明します。</p>
<p>プロジェクトに以下の依存関係を設定する必要があります。</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;io.github.takapi327&quot; %% &quot;ldbc-query-builder&quot; % &quot;0.3.0-alpha2&quot;
</code></pre>
<p>LDBCでのテーブル定義方法をまだ読んでいない場合は、<a href="/ldbc/ja/01-Table-Definitions.html">テーブル定義</a>の章を先に読むことをオススメしましす。</p>
<p>以下のコード例では、以下のimportを想定しています。</p>
<pre class="prettyprint"><code class="language-scala 3">import cats.effect.IO
import ldbc.core.*
import ldbc.query.builder.TableQuery
</code></pre>
<p>LDBCではTableQueryにテーブル定義を渡すことで型安全なクエリ構築を行います。</p>
<pre class="prettyprint"><code class="language-scala 3">case class User(
  id: Long,
  name: String,
  age: Option[Int],
)

val table = Table[User](&quot;user&quot;)(
  column(&quot;id&quot;, BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
  column(&quot;name&quot;, VARCHAR(255)),
  column(&quot;age&quot;, INT.UNSIGNED.DEFAULT(None)),
)

val userQuery = TableQuery[IO, User](table)
</code></pre>
<h2><a href="#select" name="select" class="anchor"><span class="anchor-link"></span></a>SELECT</h2>
<p>型安全にSELECT文を構築する方法はTableQueryが提供する<code>select</code>メソッドを使用することです。LDBCではプレーンなクエリに似せて実装されているため直感的にクエリ構築が行えます。またどのようなクエリが構築されているかも一目でわかるような作りになっています。</p>
<p>特定のカラムのみ取得を行うSELECT文を構築するには<code>select</code>メソッドで取得したいカラムを指定するだけです。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(_.id)

select.statement === &quot;SELECT `id` FROM user&quot;
</code></pre>
<p>複数のカラムを指定する場合は<code>select</code>メソッドで取得したいカラムを指定して指定したカラムのタプルを返すだけです。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(user =&gt; (user.id, user.name))

select.statement === &quot;SELECT `id`, `name` FROM user&quot;
</code></pre>
<p>全てのカラムを指定したい場合はTableQueryが提供する<code>selectAll</code>メソッドを使用することで構築できます。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.selectAll

select.statement === &quot;SELECT `id`, `name`, `age` FROM user&quot;
</code></pre>
<p>特定のカラムの数を取得したい場合は、指定したカラムで<code>count</code>を使用することで構築できます。　</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(_.id.count)

select.statement === &quot;SELECT COUNT(id) FROM user&quot;
</code></pre>
<h3><a href="#where" name="where" class="anchor"><span class="anchor-link"></span></a>WHERE</h3>
<p>クエリに型安全にWhere条件を設定する方法は<code>where</code>メソッドを使用することです。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(_.id).where(_.name === &quot;Test&quot;)

select.statement === &quot;SELECT `id` FROM user WHERE name = ?&quot;
</code></pre>
<p><code>where</code>メソッドで使用できる条件の一覧は以下です。</p>
<table>
  <thead>
    <tr>
      <th>条件 </th>
      <th>ステートメント </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=== </td>
      <td><code>column = ?</code> </td>
    </tr>
    <tr>
      <td>&gt;= </td>
      <td><code>column &gt;= ?</code> </td>
    </tr>
    <tr>
      <td>&gt; </td>
      <td><code>column &gt; ?</code> </td>
    </tr>
    <tr>
      <td>&lt;= </td>
      <td><code>column &lt;= ?</code> </td>
    </tr>
    <tr>
      <td>&lt; </td>
      <td><code>column &lt; ?</code> </td>
    </tr>
    <tr>
      <td>&lt;&gt; </td>
      <td><code>column &lt;&gt; ?</code> </td>
    </tr>
    <tr>
      <td>!== </td>
      <td><code>column != ?</code> </td>
    </tr>
    <tr>
      <td>IS (&ldquo;TRUE&rdquo;/&ldquo;FALSE&rdquo;/&ldquo;UNKNOWN&rdquo;/&ldquo;NULL&rdquo;) </td>
      <td><code>column IS {TRUE/FALSE/UNKNOWN/NULL}</code> </td>
    </tr>
    <tr>
      <td>&lt;=&gt; </td>
      <td><code>column &lt;=&gt; ?</code> </td>
    </tr>
    <tr>
      <td>IN (value, value, &hellip;) </td>
      <td><code>column IN (?, ?, ...)</code> </td>
    </tr>
    <tr>
      <td>BETWEEN (start, end) </td>
      <td><code>column BETWEEN ? AND ?</code> </td>
    </tr>
    <tr>
      <td>LIKE (value) </td>
      <td><code>column LIKE ?</code> </td>
    </tr>
    <tr>
      <td>LIKE_ESCAPE (like, escape) </td>
      <td><code>column LIKE ? ESCAPE ?</code> </td>
    </tr>
    <tr>
      <td>REGEXP (value) </td>
      <td><code>column REGEXP ?</code> </td>
    </tr>
    <tr>
      <td><code>&lt;&lt;</code> (value) </td>
      <td><code>column &lt;&lt; ?</code> </td>
    </tr>
    <tr>
      <td><code>&gt;&gt;</code> (value) </td>
      <td><code>column &gt;&gt; ?</code> </td>
    </tr>
    <tr>
      <td>DIV (cond, result) </td>
      <td><code>column DIV ? = ?</code> </td>
    </tr>
    <tr>
      <td>MOD (cond, result) </td>
      <td><code>column MOD ? = ?</code> </td>
    </tr>
    <tr>
      <td>^ (value) </td>
      <td><code>column ^ ?</code> </td>
    </tr>
    <tr>
      <td>~ (value) </td>
      <td><code>~column = ?</code> </td>
    </tr>
  </tbody>
</table>
<h3><a href="#group-by-having" name="group-by-having" class="anchor"><span class="anchor-link"></span></a>GROUP BY/Having</h3>
<p>クエリに型安全にGROUP BY句を設定する方法は<code>groupBy</code>メソッドを使用することです。</p>
<p><code>groupBy</code>を使用することで<code>select</code>でデータを取得する時に指定したカラム名の値を基準にグループ化することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(user =&gt; (user.id, user.name, user.age)).groupBy(_._3)

select.statement === &quot;SELECT `id`, `name`, `age` FROM user GROUP BY age&quot;
</code></pre>
<p>グループ化すると<code>select</code>で取得できるデータの数はグループの数だけとなります。そこでグループ化を行った場合には、グループ化に指定したカラムの値や、用意された関数を使ってカラムの値をグループ単位で集計した結果などを取得することができます。</p>
<p><code>having</code>を使用すると<code>groupBy</code>によってグループ化されて取得したデータに関して、取得する条件を設定することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(user =&gt; (user.id, user.name, user.age)).groupBy(_._3).having(_._3 &gt; 20)

select.statement === &quot;SELECT `id`, `name`, `age` FROM user GROUP BY age HAVING age &gt; ?&quot;
</code></pre>
<h3><a href="#order-by" name="order-by" class="anchor"><span class="anchor-link"></span></a>ORDER BY</h3>
<p>クエリに型安全にORDER BY句を設定する方法は<code>orderBy</code>メソッドを使用することです。</p>
<p><code>orderBy</code>を使うことで<code>select</code>でデータを取得する時に指定したカラムの値を対象にソートした結果を取得することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(user =&gt; (user.id, user.name, user.age)).orderBy(_.age)

select.statement === &quot;SELECT `id`, `name`, `age` FROM user ORDER BY age&quot;
</code></pre>
<p>昇順/降順を指定したい場合は、それぞれカラムに対して <code>asc</code>/<code>desc</code>を呼び出すだけです。</p>
<pre class="prettyprint"><code class="language-scala 3">val desc = userQuery.select(user =&gt; (user.id, user.name, user.age)).orderBy(_.age.desc)

desc.statement === &quot;SELECT `id`, `name`, `age` FROM user ORDER BY age DESC&quot;

val asc = userQuery.select(user =&gt; (user.id, user.name, user.age)).orderBy(_.age.asc)

asc.statement === &quot;SELECT `id`, `name`, `age` FROM user ORDER BY age ASC&quot;
</code></pre>
<h3><a href="#limit-offset" name="limit-offset" class="anchor"><span class="anchor-link"></span></a>LIMIT/OFFSET</h3>
<p>クエリに型安全にLIMIT句とOFFSET句を設定する方法は<code>limit</code>/<code>offset</code>メソッドを使用することです。</p>
<p><code>limit</code>を設定すると<code>select</code>を実行した時に取得するデータの行数の上限を設定することができ、<code>offset</code>を設定すると何番目からのデータを取得するのかを指定することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val select = userQuery.select(user =&gt; (user.id, user.name, user.age)).limit(100).offset(50)

select.statement === &quot;SELECT `id`, `name`, `age` FROM user LIMIT ? OFFSET ?&quot;
</code></pre>
<h2><a href="#join-left-join-right-join" name="join-left-join-right-join" class="anchor"><span class="anchor-link"></span></a>JOIN/LEFT JOIN/RIGHT JOIN</h2>
<p>クエリに型安全にJoinを設定する方法は<code>join</code>/<code>leftJoin</code>/<code>rightJoin</code>メソッドを使用することです。</p>
<p>Joinでは以下定義をサンプルとして使用します。</p>
<pre class="prettyprint"><code class="language-scala 3">case class Country(code: String, name: String)
object Country:
  val table = Table[Country](&quot;country&quot;)(
    column(&quot;code&quot;, CHAR(3), PRIMARY_KEY),
    column(&quot;name&quot;, VARCHAR(255))
  )

case class City(id: Long, name: String, countryCode: String)
object City:
  val table = Table[City](&quot;city&quot;)(
    column(&quot;id&quot;, BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
    column(&quot;name&quot;, VARCHAR(255)),
    column(&quot;country_code&quot;, CHAR(3))
  )

case class CountryLanguage(
  countryCode: String,
  language:    String
)
object CountryLanguage:
  val table: Table[CountryLanguage] = Table[CountryLanguage](&quot;country_language&quot;)(
    column(&quot;country_code&quot;, CHAR(3)),
    column(&quot;language&quot;, CHAR(30))
  )

val countryQuery = TableQuery[IO, Country](Country.table)
val cityQuery = TableQuery[IO, City](City.table)
val countryLanguageQuery = TableQuery[IO, CountryLanguage](CountryLanguage.table)
</code></pre>
<p>まずシンプルなJoinを行いたい場合は、<code>join</code>を使用します。 <code>join</code>の第一引数には結合したいテーブルを渡し、第二引数では結合元のテーブルと結合したいテーブルのカラムで比較を行う関数を渡します。これはJoinにおいてのON句に該当します。</p>
<p>Join後の<code>select</code>は2つのテーブルからカラムを指定することになります。</p>
<pre class="prettyprint"><code class="language-scala 3">val join = countryQuery.join(cityQuery)((country, city) =&gt; country.code === city.countryCode)
  .select((country, city) =&gt; (country.name, city.name))

join.statement = &quot;SELECT country.`name`, city.`name` FROM country JOIN city ON country.code = city.country_code&quot;
</code></pre>
<p>次に左外部結合であるLeft Joinを行いたい場合は、<code>leftJoin</code>を使用します。 <code>join</code>が<code>leftJoin</code>に変わっただけで実装自体はシンプルなJoinの時と同じになります。</p>
<pre class="prettyprint"><code class="language-scala 3">val leftJoin = countryQuery.leftJoin(cityQuery)((country, city) =&gt; country.code === city.countryCode)
  .select((country, city) =&gt; (country.name, city.name))

join.statement = &quot;SELECT country.`name`, city.`name` FROM country LEFT JOIN city ON country.code = city.country_code&quot;
</code></pre>
<p>シンプルなJoinとの違いは<code>leftJoin</code>を使用した場合、結合を行うテーブルから取得するレコードはNULLになる可能性があるということです。</p>
<p>そのためLDBCでは<code>leftJoin</code>に渡されたテーブルから取得するカラムのレコードは全てOption型になります。</p>
<pre class="prettyprint"><code class="language-scala 3">val leftJoin = countryQuery.leftJoin(cityQuery)((country, city) =&gt; country.code === city.countryCode)
  .select((country, city) =&gt; (country.name, city.name)) // (String, Option[String])
</code></pre>
<p>次に右外部結合であるRight Joinを行いたい場合は、<code>rightJoin</code>を使用します。 こちらも<code>join</code>が<code>rightJoin</code>に変わっただけで実装自体はシンプルなJoinの時と同じになります。</p>
<pre class="prettyprint"><code class="language-scala 3">val rightJoin = countryQuery.rightJoin(cityQuery)((country, city) =&gt; country.code === city.countryCode)
  .select((country, city) =&gt; (country.name, city.name))

join.statement = &quot;SELECT country.`name`, city.`name` FROM country RIGHT JOIN city ON country.code = city.country_code&quot;
</code></pre>
<p>シンプルなJoinとの違いは<code>rightJoin</code>を使用した場合、結合元のテーブルから取得するレコードはNULLになる可能性があるということです。</p>
<p>そのためLDBCでは<code>rightJoin</code>を使用した結合元のテーブルから取得するカラムのレコードは全てOption型になります。</p>
<pre class="prettyprint"><code class="language-scala 3">val rightJoin = countryQuery.rightJoin(cityQuery)((country, city) =&gt; country.code === city.countryCode)
  .select((country, city) =&gt; (country.name, city.name)) // (Option[String], String)
</code></pre>
<p>複数のJoinを行いたい場合は、メソッドチェーンで任意のJoinメソッドを呼ぶことで実現することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val join = 
  (countryQuery join cityQuery)((country, city) =&gt; country.code === city.countryCode)
    .rightJoin(countryLanguageQuery)((_, city, countryLanguage) =&gt; city.countryCode === countryLanguage.countryCode)
    .select((country, city, countryLanguage) =&gt; (country.name, city.name, countryLanguage.language)) // (Option[String], Option[String], String)]

join.statement =
  &quot;&quot;&quot;
    |SELECT
    |  country.`name`, 
    |  city.`name`,
    |  country_language.`language`
    |FROM country
    |JOIN city ON country.code = city.country_code
    |RIGHT JOIN country_language ON city.country_code = country_language.country_code
    |&quot;&quot;&quot;.stripMargin
</code></pre>
<p>複数のJoinを行っている状態で<code>rightJoin</code>での結合を行うと、今までの結合が何であったかにかかわらず直前まで結合していたテーブルから取得するレコードは全てNULL許容なアクセスとなることに注意してください。</p>
<h2><a href="#custom-data-type" name="custom-data-type" class="anchor"><span class="anchor-link"></span></a>Custom Data Type</h2>
<p>前章でユーザー独自の型もしくはサポートされていない型を使用するためにDataTypeの<code>mapping</code>メソッドを使用して独自の型とDataTypeのマッピングを行ないました。(<a href="/ldbc/ja/02-Custom-Data-Type.html">参照</a>)</p>
<p>LDBCはテーブル定義とデータベースへの接続処理が分離されています。 そのためデータベースからデータを取得する際にユーザー独自の型もしくはサポートされていない型に変換したい場合は、ResultSetからのデータ取得方法を独自の型もしくはサポートされていない型と紐付けてあげる必要があります。</p>
<p>例えばユーザー定義のEnumを文字列型とマッピングしたい場合は、以下のようになります。</p>
<pre class="prettyprint"><code class="language-scala 3">enum Custom:
  case ...

given ResultSetReader[IO, Custom] =
  ResultSetReader.mapping[IO, str, Custom](str =&gt; Custom.valueOf(str))
</code></pre>
<p>※ この処理は将来のバージョンでDataTypeのマッピングと統合される可能性があります。</p>
<h2><a href="#insert" name="insert" class="anchor"><span class="anchor-link"></span></a>INSERT</h2>
<p>型安全にINSERT文を構築する方法はTableQueryが提供する以下のメソッドを使用することです。</p>
<ul>
  <li>insert</li>
  <li>insertInto</li>
  <li>+=</li>
  <li>++=</li>
</ul>
<p><strong>insert</strong></p>
<p><code>insert</code>メソッドには挿入するデータのタプルを渡します。タプルはモデルと同じプロパティの数と型である必要があります。また、挿入されるデータの順番はモデルのプロパティおよびテーブルのカラムと同じ順番である必要があります。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insert((1L, &quot;name&quot;, None))

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?)&quot;
</code></pre>
<p>複数のデータを挿入したい場合は、<code>insert</code>メソッドに複数のタプルを渡すことで構築できます。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insert((1L, &quot;name&quot;, None), (2L, &quot;name&quot;, None))

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?), (?, ?, ?)&quot;
</code></pre>
<p><strong>insertInto</strong></p>
<p><code>insert</code>メソッドはテーブルが持つ全てのカラムにデータ挿入を行いますが、特定のカラムに対してのみデータを挿入したい場合は<code>insertInto</code>メソッドを使用します。</p>
<p>これはAutoIncrementやDefault値を持つカラムへのデータ挿入を除外したい場合などに使用できます。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insertInto(user =&gt; (user.name, user.age)).values((&quot;name&quot;, None))

insert.statement === &quot;INSERT INTO user (`name`, `age`) VALUES(?, ?)&quot;
</code></pre>
<p>複数のデータを挿入したい場合は、<code>values</code>にタプルの配列を渡すことで構築できます。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insertInto(user =&gt; (user.name, user.age)).values(List((&quot;name&quot;, None), (&quot;name&quot;, Some(20))))

insert.statement === &quot;INSERT INTO user (`name`, `age`) VALUES(?, ?), (?, ?)&quot;
</code></pre>
<p><strong>+=</strong></p>
<p><code>+=</code>メソッドを使用することでモデルを使用してinsert文を構築することができます。モデルを使用する場合は全てのカラムにデータを挿入してしまうことに注意してください。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery += User(1L, &quot;name&quot;, None)

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?)&quot;
</code></pre>
<p><strong>++=</strong></p>
<p>モデルを使用して複数のデータを挿入したい場合は<code>++=</code>メソッドを使用します。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery ++= List(User(1L, &quot;name&quot;, None), User(2L, &quot;name&quot;, None))

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?), (?, ?, ?)&quot;
</code></pre>
<h3><a href="#on-duplicate-key-update" name="on-duplicate-key-update" class="anchor"><span class="anchor-link"></span></a>ON DUPLICATE KEY UPDATE</h3>
<p>ON DUPLICATE KEY UPDATE 句を指定し行を挿入すると、UNIQUEインデックスまたはPRIMARY KEYで値が重複する場合、古い行のUPDATEが発生します。</p>
<p>LDBCでこの処理を実現する方法は2種類あり、<code>insertOrUpdate{s}</code>を使用するか、<code>Insert</code>に対して<code>onDuplicateKeyUpdate</code>を使用することです。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insertOrUpdate((1L, &quot;name&quot;, None))

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?) AS new_user ON DUPLICATE KEY UPDATE `id` = new_user.`id`, `name` = new_user.`name`, `age` = new_user.`age`&quot;
</code></pre>
<p><code>insertOrUpdate{s}</code>を使用した場合、全てのカラムが更新対象となることに注意してください。重複する値があり特定のカラムのみを更新したい場合は、<code>onDuplicateKeyUpdate</code>を使用して更新したいカラムのみを指定するようにしてください。</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insert((1L, &quot;name&quot;, None)).onDuplicateKeyUpdate(v =&gt; (v.name, v.age))

insert.statement === &quot;INSERT INTO user (`id`, `name`, `age`) VALUES(?, ?, ?) AS new_user ON DUPLICATE KEY UPDATE `name` = new_user.`name`, `age` = new_user.`age`&quot;
</code></pre>
<h2><a href="#update" name="update" class="anchor"><span class="anchor-link"></span></a>UPDATE</h2>
<p>型安全にUPDATE文を構築する方法はTableQueryが提供する<code>update</code>メソッドを使用することです。</p>
<p><code>update</code>メソッドの第1引数にはテーブルのカラム名ではなくモデルのプロパティ名を指定し、第2引数に更新したい値を渡します。第2引数に渡す値の型は第1引数で指定したプロパティの型と同じである必要があります。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(&quot;name&quot;, &quot;update name&quot;)

update.statement === &quot;UPDATE user SET name = ?&quot;
</code></pre>
<p>第1引数に存在しないプロパティ名を指定した場合コンパイルエラーとなります。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(&quot;hoge&quot;, &quot;update name&quot;) // Compile error
</code></pre>
<p>複数のカラムを更新したい場合は<code>set</code>メソッドを使用します。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(&quot;name&quot;, &quot;update name&quot;).set(&quot;age&quot;, Some(20))

update.statement === &quot;UPDATE user SET name = ?, age = ?&quot;
</code></pre>
<p><code>set</code>メソッドには条件に応じてクエリを生成させないようにすることもできます。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(&quot;name&quot;, &quot;update name&quot;).set(&quot;age&quot;, Some(20), false)

update.statement === &quot;UPDATE user SET name = ?&quot;
</code></pre>
<p>モデルを使用してupdate文を構築することもできます。モデルを使用する場合は全てのカラムを更新してしまうことに注意してください。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(User(1L, &quot;update name&quot;, None))

update.statement === &quot;UPDATE user SET id = ?, name = ?, age = ?&quot;
</code></pre>
<h3><a href="#where" name="where" class="anchor"><span class="anchor-link"></span></a>WHERE</h3>
<p><code>where</code>メソッドを使用することでupdate文にもWhere条件を設定することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val update = userQuery.update(&quot;name&quot;, &quot;update name&quot;).set(&quot;age&quot;, Some(20)).where(_.id === 1)

update.statement === &quot;UPDATE user SET name = ?, age = ? WHERE id = ?&quot;
</code></pre>
<p><code>where</code>メソッドで使用できる条件はInsert文の<a href="/ldbc/ja/03-Type-safe-Query-Builder.html#where">where項目</a>を参照してください。</p>
<h2><a href="#delete" name="delete" class="anchor"><span class="anchor-link"></span></a>DELETE</h2>
<p>型安全にDELETE文を構築する方法はTableQueryが提供する<code>delete</code>メソッドを使用することです。</p>
<pre class="prettyprint"><code class="language-scala 3">val delete = userQuery.delete

delete.statement === &quot;DELETE FROM user&quot;
</code></pre>
<h3><a href="#where" name="where" class="anchor"><span class="anchor-link"></span></a>WHERE</h3>
<p><code>where</code>メソッドを使用することでdelete文にもWhere条件を設定することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">val delete = userQuery.delete.where(_.id === 1)

delete.statement === &quot;DELETE FROM user WHERE id = ?&quot;
</code></pre>
<p><code>where</code>メソッドで使用できる条件はInsert文の<a href="/ldbc/ja/03-Type-safe-Query-Builder.html#where">where項目</a>を参照してください。</p>
<h2><a href="#ddl" name="ddl" class="anchor"><span class="anchor-link"></span></a>DDL</h2>
<p>型安全にDDLを構築する方法はTableQueryが提供する以下のメソッドを使用することです。</p>
<ul>
  <li>createTable</li>
  <li>dropTable</li>
  <li>truncateTable</li>
</ul>
<p>spec2を使用している場合は以下のようにしてテストの前後にDDLを実行することができます。</p>
<pre class="prettyprint"><code class="language-scala 3">import cats.effect.IO
import cats.effect.unsafe.implicits.global

import org.specs2.mutable.Specification
import org.specs2.specification.core.Fragments
import org.specs2.specification.BeforeAfterEach

object Test extends Specification, BeforeAfterEach:

  override def before: Fragments =
    step((tableQuery.createTable.update.autoCommit(dataSource) &gt;&gt; IO.println(&quot;Complete create table&quot;)).unsafeRunSync())

  override def after: Fragments =
    step((tableQuery.dropTable.update.autoCommit(dataSource) &gt;&gt; IO.println(&quot;Complete drop table&quot;)).unsafeRunSync())
</code></pre>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/takapi327/ldbc/tree/v0.3.0-alpha2/docs/target/mdoc/ja/03-Type-safe-Query-Builder.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../ja/04-Database-Connection.html">データベース接続</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../ja/03-Type-safe-Query-Builder.html#型安全なクエリ構築" class="header">型安全なクエリ構築</a>
  <ul>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#select" class="header">SELECT</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#join-left-join-right-join" class="header">JOIN/LEFT JOIN/RIGHT JOIN</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#custom-data-type" class="header">Custom Data Type</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#insert" class="header">INSERT</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#update" class="header">UPDATE</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#delete" class="header">DELETE</a></li>
    <li><a href="../ja/03-Type-safe-Query-Builder.html#ddl" class="header">DDL</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2024</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.3.0-alpha2', 'https://takapi327.github.io/ldbc/')});</script>


</html>
