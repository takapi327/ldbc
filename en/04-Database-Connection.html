<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Database Connection · LDBC</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Documentation for ldbc'/>
<link rel="canonical" href="https://takapi327.github.io/ldbc/../en/04-Database-Connection.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../en/index.html" >
<span class="home-icon">⌂</span>LDBC
</a>
<div class="version-number">
0.3.0-alpha9
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../en/01-Table-Definitions.html" class="page">Table Definitions</a></li>
  <li><a href="../en/02-Custom-Data-Type.html" class="page">Custom Data Type</a></li>
  <li><a href="../en/03-Type-safe-Query-Builder.html" class="page">Type-safe Query Construction</a></li>
  <li><a href="../en/04-Database-Connection.html" class="active page">Database Connection</a></li>
  <li><a href="../en/05-Plain-SQL-Queries.html" class="page">Plain SQL Queries</a></li>
  <li><a href="../en/06-Generating-SchemaSPY-Documentation.html" class="page">SchemaSPY Document Generation</a></li>
  <li><a href="../en/07-Schema-Code-Generation.html" class="page">Schema Code Generation</a></li>
  <li><a href="../en/08-Perdormance.html" class="page">Performance</a></li>
  <li><a href="../en/09-Connector.html" class="page">Connector</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../en/index.html">LDBC</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../en/index.html" >
<span class="home-icon">⌂</span>LDBC
</a>
<div class="version-number">
0.3.0-alpha9
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../en/01-Table-Definitions.html" class="page">Table Definitions</a></li>
  <li><a href="../en/02-Custom-Data-Type.html" class="page">Custom Data Type</a></li>
  <li><a href="../en/03-Type-safe-Query-Builder.html" class="page">Type-safe Query Construction</a></li>
  <li><a href="../en/04-Database-Connection.html" class="active page">Database Connection</a></li>
  <li><a href="../en/05-Plain-SQL-Queries.html" class="page">Plain SQL Queries</a></li>
  <li><a href="../en/06-Generating-SchemaSPY-Documentation.html" class="page">SchemaSPY Document Generation</a></li>
  <li><a href="../en/07-Schema-Code-Generation.html" class="page">Schema Code Generation</a></li>
  <li><a href="../en/08-Perdormance.html" class="page">Performance</a></li>
  <li><a href="../en/09-Connector.html" class="page">Connector</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../en/index.html">LDBC</a></li>
  <li>Database Connection</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#database-connection" name="database-connection" class="anchor"><span class="anchor-link"></span></a>Database Connection</h1>
<p>This chapter describes how to use queries built with LDBC to process connections to databases.</p>
<p>The following dependencies must be set up for the project</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies ++= Seq(
  &quot;io.github.takapi327&quot; %% &quot;ldbc-dsl&quot; % &quot;0.3.0-alpha9&quot;,
  &quot;com.mysql&quot; % &quot;mysql-connector-j&quot; % &quot;8.4.0&quot;
)
</code></pre>
<p>If you have not yet read about how to build queries with LDBC, we recommend that you read the chapter <a href="/ldbc/en/03-Type-safe-Query-Builder.html">Building Type-Safe Queries</a> first.</p>
<p>The following code example assumes the following import</p>
<pre class="prettyprint"><code class="language-scala 3">import com.mysql.cj.jdbc.MysqlDataSource

import cats.effect.IO
// This is just for testing. Consider using cats.effect.IOApp instead of calling
// unsafe methods directly.
import cats.effect.unsafe.implicits.global

import ldbc.sql.*
import ldbc.dsl.io.*
import ldbc.dsl.logging.LogHandler
import ldbc.query.builder.TableQuery
</code></pre>
<p>Table definitions use the following</p>
<pre class="prettyprint"><code class="language-scala 3">case class User(
  id: Long,
  name: String,
  age: Option[Int],
)

val table = Table[User](&quot;user&quot;)(
  column(&quot;id&quot;, BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
  column(&quot;name&quot;, VARCHAR(255)),
  column(&quot;age&quot;, INT.UNSIGNED.DEFAULT(None)),
)

val userQuery = TableQuery[IO, User](table)
</code></pre>
<h2><a href="#using-datasource" name="using-datasource" class="anchor"><span class="anchor-link"></span></a>Using DataSource</h2>
<p>LDBC uses JDBC&rsquo;s DataSource for database connections, and since LDBC does not provide an implementation for building this DataSource, it is necessary to use a library such as mysql or HikariCP. In this example, we will use mysqlDataSource to build the DataSource.</p>
<pre class="prettyprint"><code class="language-scala 3">private val dataSource = new MysqlDataSource()
dataSource.setServerName(&quot;127.0.0.1&quot;)
dataSource.setPortNumber(3306)
dataSource.setDatabaseName(&quot;database name&quot;)
dataSource.setUser(&quot;user name&quot;)
dataSource.setPassword(&quot;password&quot;)
</code></pre>
<h2><a href="#log" name="log" class="anchor"><span class="anchor-link"></span></a>Log</h2>
<p>LDBC can export execution and error logs of Database connections in any format using any logging library.</p>
<p>A logger using Cats Effect&rsquo;s Console is provided as standard, which can be used during development.</p>
<pre class="prettyprint"><code class="language-scala 3">given LogHandler[IO] = LogHandler.consoleLogger
</code></pre>
<h3><a href="#customize" name="customize" class="anchor"><span class="anchor-link"></span></a>Customize</h3>
<p>Use <code>ldbc.dsl.logging.LogHandler</code> to customize logs using any logging library.</p>
<p>The following is the standard implementation of logging: LDBC generates the following three types of events on database connections</p>
<ul>
  <li>Success: Successful processing</li>
  <li>ProcessingFailure: Error in processing after data acquisition or before database connection</li>
  <li>ExecFailure: Error processing connection to database</li>
</ul>
<p>Pattern matching is used to sort out what logs to write for each event.</p>
<pre class="prettyprint"><code class="language-scala 3">def consoleLogger[F[_]: Console: Sync]: LogHandler[F] =
  case LogEvent.Success(sql, args) =&gt;
    Console[F].println(
      s&quot;&quot;&quot;Successful Statement Execution:
         |  $sql
         |
         | arguments = [${ args.mkString(&quot;,&quot;) }]
         |&quot;&quot;&quot;.stripMargin
    )
  case LogEvent.ProcessingFailure(sql, args, failure) =&gt;
    Console[F].errorln(
      s&quot;&quot;&quot;Failed ResultSet Processing:
         |  $sql
         |
         | arguments = [${ args.mkString(&quot;,&quot;) }]
         |&quot;&quot;&quot;.stripMargin
    ) &gt;&gt; Console[F].printStackTrace(failure)
  case LogEvent.ExecFailure(sql, args, failure) =&gt;
    Console[F].errorln(
      s&quot;&quot;&quot;Failed Statement Execution:
         |  $sql
         |
         | arguments = [${ args.mkString(&quot;,&quot;) }]
         |&quot;&quot;&quot;.stripMargin
    ) &gt;&gt; Console[F].printStackTrace(failure)
</code></pre>
<h2><a href="#query" name="query" class="anchor"><span class="anchor-link"></span></a>Query</h2>
<p>Constructing a <code>select</code> statement allows the use of the <code>toList</code>/<code>headOption</code>/<code>unsafe</code> methods. These methods are used to determine the format of the data to be retrieved. If you do not specify any particular type, the column type specified in the <code>select</code> method will be returned as a Tuple.</p>
<h3><a href="#tolist" name="tolist" class="anchor"><span class="anchor-link"></span></a>toList</h3>
<p>The <code>toList</code> method is used to retrieve a list of data as a result of executing a query. If you use the <code>toList</code> method to process the database and get zero data, an empty array will be returned.</p>
<pre class="prettyprint"><code class="language-scala 3">val query1 = userQuery.selectAll.toList // List[(Long, String, Option[Int])]
</code></pre>
<p>Specifying a model in the <code>toList</code> method allows the data after acquisition to be converted to the specified model.</p>
<pre class="prettyprint"><code class="language-scala 3">val query = userQuery.selectAll.toList[User] // User
</code></pre>
<p>The model type specified in the <code>toList</code> method must match the Tuple type specified in the <code>select</code> method or be type-convertible from the Tuple type to the specified model.</p>
<pre class="prettyprint"><code class="language-scala 3">val query1 = userQuery.select(user =&gt; (user.name, user.age)).toList[User] // Compile error

case class Test(name: String, age: Option[Int])
val query2 = userQuery.select(user =&gt; (user.name, user.age)).toList[Test] // Test
</code></pre>
<h3><a href="#headoption" name="headoption" class="anchor"><span class="anchor-link"></span></a>headOption</h3>
<p>If you want to get the first data as an Optional result of the query, use the <code>headOption</code> method. If the result of database processing using the <code>headOption</code> method is zero, none is returned.</p>
<p>Note that if you use the <code>headOption</code> method, only the first data will be returned, even if you execute a query that retrieves multiple data.</p>
<pre class="prettyprint"><code class="language-scala 3">val query1 = userQuery.selectAll.headOption // Option[(Long, String, Option[Int])]
val query2 = userQuery.selectAll.headOption[User] // Option[User]
</code></pre>
<h3><a href="#unsafe" name="unsafe" class="anchor"><span class="anchor-link"></span></a>unsafe</h3>
<p>When using the <code>unsafe</code> method, it is the same as the <code>headOption</code> method in that it returns only the first case of the retrieved data, but the data is returned as is, not as Optional. If the number of data returned is zero, an exception will be raised and appropriate exception handling is required.</p>
<p>It is named <code>unsafe</code> because it is likely to raise an exception at runtime.</p>
<pre class="prettyprint"><code class="language-scala 3">val query1 = userQuery.selectAll.unsafe // (Long, String, Option[Int])
val query2 = userQuery.selectAll.unsafe[User] // User
</code></pre>
<h2><a href="#update" name="update" class="anchor"><span class="anchor-link"></span></a>Update</h2>
<p>Constructing an <code>insert/update/delete</code> statement allows you to use the <code>update</code> method. The <code>update</code> method returns the number of write operations to the database.</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insert((1L, &quot;name&quot;, None)).update // Int
val update = userQuery.update(&quot;name&quot;, &quot;update name&quot;).update // Int
val delete = userQuery.delete.update // Int
</code></pre>
<p>In the case of an <code>insert</code> statement, you may want the values generated by AutoIncrement to be returned when inserting data. In this case, use the <code>returning</code> method instead of the <code>update</code> method to specify the columns to be returned.</p>
<pre class="prettyprint"><code class="language-scala 3">val insert = userQuery.insert((1L, &quot;name&quot;, None)).returning(&quot;id&quot;) // Long
</code></pre>
<p>The value specified in the <code>returning</code> method must be the name of a property that the model has. Also, if the specified property does not have the AutoIncrement attribute set on the table definition, an error will occur.</p>
<p>In MySQL, the only value that can be returned when inserting data is the AutoIncrement column, so the same specification applies to LDBC.</p>
<h2><a href="#perform-database-operations" name="perform-database-operations" class="anchor"><span class="anchor-link"></span></a>Perform database operations</h2>
<p>Before making a database connection, commit timing, read/write-only, and other settings must be made.</p>
<h3><a href="#read-only" name="read-only" class="anchor"><span class="anchor-link"></span></a>Read Only</h3>
<p>The <code>readOnly</code> method can be used to make the processing of a query to be executed read-only. The <code>readOnly</code> method can also be used with <code>insert/update/delete</code> statements, but it will result in an error at runtime because of the write operation.</p>
<pre class="prettyprint"><code class="language-scala 3">val read = userQuery.selectAll.toList.readOnly(dataSource)
</code></pre>
<h3><a href="#auto-commit" name="auto-commit" class="anchor"><span class="anchor-link"></span></a>Auto Commit</h3>
<p>The <code>autoCommit</code> method can be used to set the query processing to commit at each query execution.</p>
<pre class="prettyprint"><code class="language-scala 3">val read = userQuery.insert((1L, &quot;name&quot;, None)).update.autoCommit(dataSource)
</code></pre>
<h3><a href="#transaction" name="transaction" class="anchor"><span class="anchor-link"></span></a>Transaction</h3>
<p>The <code>transaction</code> method can be used to combine multiple database connection operations into a single transaction.</p>
<p>The return value of the <code>toList/headOption/unsafe/returning/update</code> method is of type <code>Kleisli[F, Connection[F], T]</code>. Therefore, you can use map or flatMap to combine the process into one.</p>
<p>By using the <code>transaction</code> method on a single <code>Kleisli[F, Connection[F], T]</code>, all database connection operations performed within will be combined into a single transaction.</p>
<pre class="prettyprint"><code class="language-scala 3">(for
  result1 &lt;- userQuery.insert((1L, &quot;name&quot;, None)).returning(&quot;id&quot;)
  result2 &lt;- userQuery.update(&quot;name&quot;, &quot;update name&quot;).update
  ...
yield ...).transaction(dataSource)
</code></pre>
<h2><a href="#database-action" name="database-action" class="anchor"><span class="anchor-link"></span></a>Database Action</h2>
<p>There is also a way to perform database processing using <code>Database</code> with connection information to the database.</p>
<p>There are two ways to construct a <code>Database</code>: using the DriverManager or generating one from a DataSource. The following is an example of constructing a <code>Database</code> with connection information to a database using a MySQL driver.</p>
<pre class="prettyprint"><code class="language-scala 3">val db = Database.fromMySQLDriver[IO](&quot;database name&quot;, &quot;host&quot;, &quot;port number&quot;, &quot;user name&quot;, &quot;password&quot;)
</code></pre>
<p>The advantages of using <code>Database</code> to perform database processing are as follows</p>
<ul>
  <li>Simplifies DataSource construction (when using DriverManager)</li>
  <li>Eliminates the need to pass a DataSource for each query</li>
</ul>
<p>The method using <code>Database</code> is merely a simplified method of passing a DataSource, so there is no difference in execution results between the two. The only difference is whether the processes are combined using <code>flatMap</code> or other methods and executed in a method chain, or whether the combined processes are executed using <code>Database</code>. Therefore, the user can choose the execution method of his/her choice.</p>
<p><strong>Read Only</strong></p>
<pre class="prettyprint"><code class="language-scala 3">val user: Option[User] = db.readOnly(userQuery.selectAll.headOption[User]).unsafeRunSync()
</code></pre>
<p><strong>Auto Commit</strong></p>
<pre class="prettyprint"><code class="language-scala 3">val result = db.autoCommit(userQuery.insert((1L, &quot;name&quot;, None)).update).unsafeRunSync()
</code></pre>
<p><strong>Transaction</strong></p>
<pre class="prettyprint"><code class="language-scala 3">db.transaction(for
  result1 &lt;- userQuery.insert((1L, &quot;name&quot;, None)).returning(&quot;id&quot;)
  result2 &lt;- userQuery.update(&quot;name&quot;, &quot;update name&quot;).update
  ...
yield ...).unsafeRunSync()
</code></pre>
<h3><a href="#database-model" name="database-model" class="anchor"><span class="anchor-link"></span></a>Database model</h3>
<p>In LDBC, the <code>Database</code> model is also used for purposes other than holding database connection information. Another use is for SchemaSPY documentation generation, see <a href="/ldbc/ja/06-Generating-SchemaSPY-Documentation.html">here</a> for information on SchemaSPY document generation.</p>
<p>If you have already generated a <code>Database</code> model for another use, you can use that model to build a <code>Database</code> with database connection information.</p>
<pre class="prettyprint"><code class="language-scala 3">import ldbc.dsl.io.*

val database: Database = ???

val db = database.fromDriverManager()
// or
val db = database.fromDriverManager(&quot;user name&quot;, &quot;password&quot;)
</code></pre>
<h3><a href="#use-in-method-chain" name="use-in-method-chain" class="anchor"><span class="anchor-link"></span></a>Use in method chain</h3>
<p>The <code>Database</code> model can also be used in place of <code>DataSource</code> in <code>TableQuery</code> methods.</p>
<pre class="prettyprint"><code class="language-scala 3">val read = userQuery.selectAll.toList.readOnly(db)
val commit = userQuery.insert((1L, &quot;name&quot;, None)).update.autoCommit(db)
val transaction = (for
  result1 &lt;- userQuery.insert((1L, &quot;name&quot;, None)).returning(&quot;id&quot;)
  result2 &lt;- userQuery.update(&quot;name&quot;, &quot;update name&quot;).update
  ...
yield ...).transaction(db)
</code></pre>
<h2><a href="#using-a-hikaricp-connection-pool" name="using-a-hikaricp-connection-pool" class="anchor"><span class="anchor-link"></span></a>Using a HikariCP Connection Pool</h2>
<p><code>ldbc-hikari</code> provides a builder to build HikariConfig and HikariDataSource for building HikariCP connection pools.</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies ++= Seq(
  &quot;io.github.takapi327&quot; %% &quot;ldbc-hikari&quot; % &quot;0.3.0-alpha9&quot;,
)
</code></pre>
<p><code>HikariConfigBuilder</code> is a builder to build <code>HikariConfig</code> of HikariCP as the name suggests.</p>
<pre class="prettyprint"><code class="language-scala 3">val hikariConfig: com.zaxxer.hikari.HikariConfig = HikariConfigBuilder.default.build()
</code></pre>
<p>The <code>HikariConfigBuilder</code> has a <code>default</code> and a <code>from</code> method. When <code>default</code> is used, the <code>HikariConfig</code> is constructed by retrieving the target values from the Config based on the LDBC specified path.</p>
<pre class="prettyprint"><code class="nocode">ldbc.hikari {
  jdbc_url = ...
  username = ...
  password = ...
}
</code></pre>
<p>If you want to specify a user-specific path, you must use the <code>from</code> method and pass the path you want to retrieve as an argument.</p>
<pre class="prettyprint"><code class="language-scala 3">val hikariConfig: com.zaxxer.hikari.HikariConfig = HikariConfigBuilder.from(&quot;custom.path&quot;).build()

// custom.path {
//   jdbc_url = ...
//   username = ...
//   password = ...
// }
</code></pre>
<p>Please refer to <a href="https://github.com/brettwooldridge/HikariCP">official</a> for details on what can be set in HikariCP.</p>
<p>The following is a list of keys that can be set for Config.</p>
<table>
  <thead>
    <tr>
      <th>Key name </th>
      <th>Description </th>
      <th>Type </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>catalog </td>
      <td>Default catalog name to be set when connecting </td>
      <td>String </td>
    </tr>
    <tr>
      <td>connection_timeout </td>
      <td>Maximum number of milliseconds the client will wait for a connection from the pool </td>
      <td>Duration </td>
    </tr>
    <tr>
      <td>idle_timeout </td>
      <td>Maximum time (in milliseconds) that a connection is allowed to be idle in the pool </td>
      <td>Duration </td>
    </tr>
    <tr>
      <td>leak_detection_threshold </td>
      <td>Time a connection is out of the pool before a message indicating a possible connection leak is logged </td>
      <td>Duration </td>
    </tr>
    <tr>
      <td>maximum_pool_size </td>
      <td>Maximum size allowed by the pool, including both idle and in-use connections </td>
      <td>Int </td>
    </tr>
    <tr>
      <td>max_lifetime </td>
      <td>Maximum lifetime of connections in the pool </td>
      <td>Duration </td>
    </tr>
    <tr>
      <td>minimum_idle </td>
      <td>Minimum number of idle connections that HikariCP will try to keep in the pool, including both idle and in-use connections </td>
      <td>Int </td>
    </tr>
    <tr>
      <td>pool_name </td>
      <td>Connection pool name </td>
      <td>String </td>
    </tr>
    <tr>
      <td>allow_pool_suspension </td>
      <td>Whether to allow pool suspend </td>
      <td>Boolean </td>
    </tr>
    <tr>
      <td>auto_commit </td>
      <td>Default autocommit behavior for connections in the pool </td>
      <td>Boolean </td>
    </tr>
    <tr>
      <td>connection_init_sql </td>
      <td>SQL string to be executed when a new connection is created, before it is added to the pool </td>
      <td>String </td>
    </tr>
    <tr>
      <td>connection_test_query </td>
      <td>SQL query to execute to test the validity of the connection </td>
      <td>String </td>
    </tr>
    <tr>
      <td>data_source_classname </td>
      <td>Fully qualified class name of the JDBC DataSource to be used to create Connections </td>
      <td>String </td>
    </tr>
    <tr>
      <td>initialization_fail_timeout </td>
      <td>Pool initialization failure timeout </td>
      <td>Duration </td>
    </tr>
    <tr>
      <td>isolate_internal_queries </td>
      <td>Whether internal pool queries (mainly validity checks) are separated in their own transaction by <code>Connection.rollback()</code>. </td>
      <td>Boolean </td>
    </tr>
    <tr>
      <td>jdbc_url </td>
      <td>JDBC URL </td>
      <td>String </td>
    </tr>
    <tr>
      <td>readonly </td>
      <td>Whether connections to be added to the pool should be set as read-only connections </td>
      <td>Boolean </td>
    </tr>
    <tr>
      <td>register_mbeans </td>
      <td>Whether HikariCP self-registers HikariConfigMXBean and HikariPoolMXBean in JMX </td>
      <td>Boolean </td>
    </tr>
    <tr>
      <td>schema </td>
      <td>Default schema name to set when connecting </td>
      <td>String </td>
    </tr>
    <tr>
      <td>username </td>
      <td>Default username used for calls to <code>DataSource.getConnection(username,password)</code> </td>
      <td>String </td>
    </tr>
    <tr>
      <td>password </td>
      <td>Default password used for calling <code>DataSource.getConnection(username,password)</code> </td>
      <td>String </td>
    </tr>
    <tr>
      <td>driver_class_name </td>
      <td>Driver class name to be used </td>
      <td>String </td>
    </tr>
    <tr>
      <td>transaction_isolation </td>
      <td>Default transaction isolation level </td>
      <td>String </td>
    </tr>
  </tbody>
</table>
<p>The <code>HikariDataSourceBuilder</code> allows you to build a <code>HikariDataSource</code> for HikariCP.</p>
<p>The <code>HikariDataSource</code> built by the builder is managed as a <code>Resource</code> since the connection pool is a lifetime managed object and needs to be shut down cleanly.</p>
<pre class="prettyprint"><code class="language-scala 3">val dataSource: Resource[IO, HikariDataSource] = HikariDataSourceBuilder.default[IO].buildDataSource()
</code></pre>
<p>The <code>HikariDataSource</code> built via <code>buildDataSource</code> uses <code>HikariConfig</code>, which is built internally by retrieving settings from Config based on the LDBC specified path. This is equivalent to <code>HikariConfig</code> generated via <code>default</code> in <code>HikariConfigBuilder</code>.</p>
<p>If you want to use a user-specified <code>HikariConfig</code>, you can use <code>buildFromConfig</code> to build a <code>HikariDataSource</code>.</p>
<pre class="prettyprint"><code class="language-scala 3">val hikariConfig = ???
val dataSource = HikariDataSourceBuilder.default[IO].buildFromConfig(hikariConfig)
</code></pre>
<p>A <code>HikariDataSource</code> built with <code>HikariDataSourceBuilder</code> is usually executed using IOApp.</p>
<pre class="prettyprint"><code class="language-scala 3">object HikariApp extends IOApp:

  val dataSourceResource: Resource[IO, HikariDataSource] = HikariDataSourceBuilder.default[IO].buildDataSource()

  def run(args: List[String]): IO[ExitCode] =
    dataSourceResource.use { dataSource =&gt;
       ...
    }
</code></pre>
<h3><a href="#hikaridatabase" name="hikaridatabase" class="anchor"><span class="anchor-link"></span></a>HikariDatabase</h3>
<p>There is also a way to build a <code>Database</code> with HikariCP connection information.</p>
<p>The <code>HikariDatabase</code> is managed as a <code>Resource</code> like the <code>HikariDataSource</code>. Therefore, it is usually executed using IOApp.</p>
<pre class="prettyprint"><code class="language-scala 3">object HikariApp extends IOApp:

  val hikariConfig = ???
  val databaseResource: Resource[F, Database[F]] = HikariDatabase.fromHikariConfig[IO](hikariConfig)

  def run(args: List[String]): IO[ExitCode] =
    databaseResource.use { database =&gt;
       for
         result &lt;- database.readOnly(...)
        yield ExitCode.Success
    }
</code></pre>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/takapi327/ldbc/tree/v0.3.0-alpha9/docs/target/mdoc/en/04-Database-Connection.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../en/05-Plain-SQL-Queries.html">Plain SQL Queries</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../en/04-Database-Connection.html#database-connection" class="header">Database Connection</a>
  <ul>
    <li><a href="../en/04-Database-Connection.html#using-datasource" class="header">Using DataSource</a></li>
    <li><a href="../en/04-Database-Connection.html#log" class="header">Log</a></li>
    <li><a href="../en/04-Database-Connection.html#query" class="header">Query</a></li>
    <li><a href="../en/04-Database-Connection.html#update" class="header">Update</a></li>
    <li><a href="../en/04-Database-Connection.html#perform-database-operations" class="header">Perform database operations</a></li>
    <li><a href="../en/04-Database-Connection.html#database-action" class="header">Database Action</a></li>
    <li><a href="../en/04-Database-Connection.html#using-a-hikaricp-connection-pool" class="header">Using a HikariCP Connection Pool</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2024</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.3.0-alpha9', 'https://takapi327.github.io/ldbc/')});</script>


</html>
